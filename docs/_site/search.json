[
  {
    "objectID": "running_simulations.html",
    "href": "running_simulations.html",
    "title": "SwimmingIndividuals.jl",
    "section": "",
    "text": "Once the model components are initialized, the simulation is ready to be run. The core logic for managing and executing the time-stepping loop is handled by the simulation.jl and update.jl files. These files define the main simulation object and the function that drives the model forward in time.\n\n\nThis file defines the primary data structures that hold the simulation’s state and its outputs.\n\nMarineOutputs: This struct is a container for all the large, multi-dimensional arrays that store the results of the simulation, such as mortality rates and consumption grids. Defining these in a separate struct keeps the main model object cleaner and easier to manage. The fields are defined as AbstractArray to ensure they are compatible with both standard CPU Arrays and CUDA.CuArrays for GPU execution.\nMarineSimulation: This is the main “runner” object for a single simulation experiment. It bundles the complete MarineModel state with run-specific parameters like the timestep duration (ΔT), the total number of iterations, and the MarineOutputs container.\n\n# In simulation.jl\n\n# ===================================================================\n# Data Structures for Simulation and Output\n# ===================================================================\n\n\"\"\"\n    MarineOutputs\nA mutable struct to hold all the data generated during a simulation run.\nThe fields are defined as `AbstractArray` to be compatible with both\nCPU `Array`s and GPU `CuArray`s.\n\"\"\"\nmutable struct MarineOutputs\n    mortalities::AbstractArray{Int64,5}\n    Fmort::AbstractArray{Int64,5}\n    consumption::AbstractArray{Float64,5}\n    abundance::AbstractArray{Float64,4}\nend\n\n\n\"\"\"\n    MarineSimulation\nThe main \"runner\" object for a single simulation experiment. It bundles\nthe model state with run-specific parameters\n\"\"\"\nmutable struct MarineSimulation\n    model::MarineModel\n    ΔT::Float64\n    iterations::Int64\n    run::Int64\n    outputs::MarineOutputs\nend\n\n\n\nThis file contains the primary function that executes the simulation.\n\n\n# In update.jl\n\n# ===================================================================\n# Main Simulation Driver\n# ===================================================================\n\n\"\"\"\n    runSI(sim::MarineSimulation)\n\nA simple wrapper function to start the simulation. This can be used as the\nmain entry point in your `model.jl` script.\n\"\"\"\nfunction runSI(sim::MarineSimulation)\n    println(\"✅ Model Initialized. Starting simulation run...\")\n    for i in 1:sim.iterations\n        TimeStep!(sim)\n    end\n    println(\"✅ Simulation run complete.\")\nend",
    "crumbs": [
      "Running Simulations"
    ]
  },
  {
    "objectID": "running_simulations.html#running-simulations",
    "href": "running_simulations.html#running-simulations",
    "title": "SwimmingIndividuals.jl",
    "section": "",
    "text": "Once the model components are initialized, the simulation is ready to be run. The core logic for managing and executing the time-stepping loop is handled by the simulation.jl and update.jl files. These files define the main simulation object and the function that drives the model forward in time.\n\n\nThis file defines the primary data structures that hold the simulation’s state and its outputs.\n\nMarineOutputs: This struct is a container for all the large, multi-dimensional arrays that store the results of the simulation, such as mortality rates and consumption grids. Defining these in a separate struct keeps the main model object cleaner and easier to manage. The fields are defined as AbstractArray to ensure they are compatible with both standard CPU Arrays and CUDA.CuArrays for GPU execution.\nMarineSimulation: This is the main “runner” object for a single simulation experiment. It bundles the complete MarineModel state with run-specific parameters like the timestep duration (ΔT), the total number of iterations, and the MarineOutputs container.\n\n# In simulation.jl\n\n# ===================================================================\n# Data Structures for Simulation and Output\n# ===================================================================\n\n\"\"\"\n    MarineOutputs\nA mutable struct to hold all the data generated during a simulation run.\nThe fields are defined as `AbstractArray` to be compatible with both\nCPU `Array`s and GPU `CuArray`s.\n\"\"\"\nmutable struct MarineOutputs\n    mortalities::AbstractArray{Int64,5}\n    Fmort::AbstractArray{Int64,5}\n    consumption::AbstractArray{Float64,5}\n    abundance::AbstractArray{Float64,4}\nend\n\n\n\"\"\"\n    MarineSimulation\nThe main \"runner\" object for a single simulation experiment. It bundles\nthe model state with run-specific parameters\n\"\"\"\nmutable struct MarineSimulation\n    model::MarineModel\n    ΔT::Float64\n    iterations::Int64\n    run::Int64\n    outputs::MarineOutputs\nend\n\n\n\nThis file contains the primary function that executes the simulation.\n\n\n# In update.jl\n\n# ===================================================================\n# Main Simulation Driver\n# ===================================================================\n\n\"\"\"\n    runSI(sim::MarineSimulation)\n\nA simple wrapper function to start the simulation. This can be used as the\nmain entry point in your `model.jl` script.\n\"\"\"\nfunction runSI(sim::MarineSimulation)\n    println(\"✅ Model Initialized. Starting simulation run...\")\n    for i in 1:sim.iterations\n        TimeStep!(sim)\n    end\n    println(\"✅ Simulation run complete.\")\nend",
    "crumbs": [
      "Running Simulations"
    ]
  },
  {
    "objectID": "inputs.html",
    "href": "inputs.html",
    "title": "Model Inputs",
    "section": "",
    "text": "The SwimmingIndividuals.jl model is highly flexible and is configured through a series of user-provided input files. These files define everything from the biological traits of the species to the physical environment and the rules of the fisheries. All input files are expected to be located in the /inputs directory of the project.\n\n\n\nThis is the master file that tells the model where to find all other input data. It is a simple CSV with two columns that allows you to easily switch between different sets of input files without changing the main model code.\n\n\n\n\n\n\n\nColumn\nDescription\n\n\n\n\nFile\nA unique key for the data file (e.g., focal_trait).\n\n\nDestination\nThe relative path to the corresponding file.\n\n\n\nExample File Manifest (files.csv):\n\n\n\nFile\nDestination\n\n\n\n\nfocal_trait\ninputs/focal_trait.csv\n\n\nresource_trait\ninputs/resource_trait.csv\n\n\nparams\ninputs/params.csv\n\n\ngrid\ninputs/grid.csv\n\n\nfisheries\ninputs/fisheries.csv\n\n\nenvironment\ninputs/environment.nc\n\n\n\n\n\n\n\nThis file controls the high-level configuration of the simulation run.\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nnumspec\nNumber of focal species to simulate.\n\n\nnumresource\nNumber of resource species to simulate.\n\n\nnts\nTotal number of timesteps for the simulation.\n\n\nmodel_dt\nDuration of a single timestep (minutes).\n\n\noutput_dt\nFrequency (in timesteps) at which to save outputs.\n\n\narchitecture\nComputational backend to use (CPU or GPU).\n\n\nspinup\nNumber of timesteps for model burn-in before output.\n\n\nplt_diags\nBoolean (1 or 0) for generating diagnostic plots.\n\n\n\n\n\n\n\nThese files contain all biological and behavioral parameters for the simulated species. Each row represents a species.\n\n\n\n\n\n\n\nColumn\nDescription\n\n\n\n\nSpeciesLong\nFull name of the species.\n\n\nBiomass\nInitial biomass density.\n\n\nMax_Size\nMaximum length (mm) the species can attain.\n\n\nLWR_a, LWR_b\nLength-weight relationship parameters.\n\n\nMR_type\nMetabolic rate model (e.g., 1 for standard, 2 for cetacean).\n\n\nSwim_velo\nSwim speed parameter.\n\n\nType\nBehavioral archetype (e.g., dvm_strong, pelagic_diver).\n\n\n…\n(Many other parameters for bioenergetics, predation, and behavior.)\n\n\n\n\n\n\n\nDefines habitat suitability for each species based on environmental variables.\n\n\n\n\n\n\n\nColumn\nDescription\n\n\n\n\nspecies\nSpecies name (must match trait files).\n\n\nvariable\nEnvironmental variable (temp-surf, bathymetry, etc.).\n\n\npref_min\nAbsolute minimum tolerated value.\n\n\nopt_min\nLower bound of optimal range.\n\n\nopt_max\nUpper bound of optimal range.\n\n\npref_max\nAbsolute maximum tolerated value.\n\n\n\n\n\n\n\nDefines fishing rules and quotas for the simulation.\n\n\n\n\n\n\n\nColumn\nDescription\n\n\n\n\nFisheryName\nName of the fishery.\n\n\nSpecies\nTargeted species.\n\n\nRole\nRole of species (target or bycatch).\n\n\nQuota\nTotal allowable catch (tonnes).\n\n\nStartDay, EndDay\nFishing season boundaries.\n\n\nL50, Slope\nGear selectivity parameters.\n\n\n…\n(Additional columns for area, size limits, etc.)\n\n\n\n\n\n\n\nA NetCDF file containing spatial and temporal environmental variables for the model domain. It supports flexible dimensions and variable types.\n\n\n\n\n\n\n\n\nVariable\nDimensions\nDescription\n\n\n\n\ntemp\n4D\nFull water column temperature grid.\n\n\ntemp-surf\n3D\nSea surface temperature.\n\n\nsalinity\n3D or 4D\nSalinity values.\n\n\nchl\n3D\nSurface chlorophyll concentration.\n\n\nbathymetry\n2D\nSeafloor depth.\n\n\n\n\nThese input files form the backbone of your SwimmingIndividuals.jl simulation and allow extensive flexibility in configuring species traits, environmental drivers, and human impacts.",
    "crumbs": [
      "Model Inputs"
    ]
  },
  {
    "objectID": "inputs.html#the-file-manifest-files.csv",
    "href": "inputs.html#the-file-manifest-files.csv",
    "title": "Model Inputs",
    "section": "",
    "text": "This is the master file that tells the model where to find all other input data. It is a simple CSV with two columns that allows you to easily switch between different sets of input files without changing the main model code.\n\n\n\n\n\n\n\nColumn\nDescription\n\n\n\n\nFile\nA unique key for the data file (e.g., focal_trait).\n\n\nDestination\nThe relative path to the corresponding file.\n\n\n\nExample File Manifest (files.csv):\n\n\n\nFile\nDestination\n\n\n\n\nfocal_trait\ninputs/focal_trait.csv\n\n\nresource_trait\ninputs/resource_trait.csv\n\n\nparams\ninputs/params.csv\n\n\ngrid\ninputs/grid.csv\n\n\nfisheries\ninputs/fisheries.csv\n\n\nenvironment\ninputs/environment.nc",
    "crumbs": [
      "Model Inputs"
    ]
  },
  {
    "objectID": "inputs.html#main-parameters-params.csv",
    "href": "inputs.html#main-parameters-params.csv",
    "title": "Model Inputs",
    "section": "",
    "text": "This file controls the high-level configuration of the simulation run.\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nnumspec\nNumber of focal species to simulate.\n\n\nnumresource\nNumber of resource species to simulate.\n\n\nnts\nTotal number of timesteps for the simulation.\n\n\nmodel_dt\nDuration of a single timestep (minutes).\n\n\noutput_dt\nFrequency (in timesteps) at which to save outputs.\n\n\narchitecture\nComputational backend to use (CPU or GPU).\n\n\nspinup\nNumber of timesteps for model burn-in before output.\n\n\nplt_diags\nBoolean (1 or 0) for generating diagnostic plots.",
    "crumbs": [
      "Model Inputs"
    ]
  },
  {
    "objectID": "inputs.html#trait-files-focal_trait.csv-resource_trait.csv",
    "href": "inputs.html#trait-files-focal_trait.csv-resource_trait.csv",
    "title": "Model Inputs",
    "section": "",
    "text": "These files contain all biological and behavioral parameters for the simulated species. Each row represents a species.\n\n\n\n\n\n\n\nColumn\nDescription\n\n\n\n\nSpeciesLong\nFull name of the species.\n\n\nBiomass\nInitial biomass density.\n\n\nMax_Size\nMaximum length (mm) the species can attain.\n\n\nLWR_a, LWR_b\nLength-weight relationship parameters.\n\n\nMR_type\nMetabolic rate model (e.g., 1 for standard, 2 for cetacean).\n\n\nSwim_velo\nSwim speed parameter.\n\n\nType\nBehavioral archetype (e.g., dvm_strong, pelagic_diver).\n\n\n…\n(Many other parameters for bioenergetics, predation, and behavior.)",
    "crumbs": [
      "Model Inputs"
    ]
  },
  {
    "objectID": "inputs.html#environmental-preferences-envi_pref.csv",
    "href": "inputs.html#environmental-preferences-envi_pref.csv",
    "title": "Model Inputs",
    "section": "",
    "text": "Defines habitat suitability for each species based on environmental variables.\n\n\n\n\n\n\n\nColumn\nDescription\n\n\n\n\nspecies\nSpecies name (must match trait files).\n\n\nvariable\nEnvironmental variable (temp-surf, bathymetry, etc.).\n\n\npref_min\nAbsolute minimum tolerated value.\n\n\nopt_min\nLower bound of optimal range.\n\n\nopt_max\nUpper bound of optimal range.\n\n\npref_max\nAbsolute maximum tolerated value.",
    "crumbs": [
      "Model Inputs"
    ]
  },
  {
    "objectID": "inputs.html#fishery-regulations-fisheries.csv",
    "href": "inputs.html#fishery-regulations-fisheries.csv",
    "title": "Model Inputs",
    "section": "",
    "text": "Defines fishing rules and quotas for the simulation.\n\n\n\n\n\n\n\nColumn\nDescription\n\n\n\n\nFisheryName\nName of the fishery.\n\n\nSpecies\nTargeted species.\n\n\nRole\nRole of species (target or bycatch).\n\n\nQuota\nTotal allowable catch (tonnes).\n\n\nStartDay, EndDay\nFishing season boundaries.\n\n\nL50, Slope\nGear selectivity parameters.\n\n\n…\n(Additional columns for area, size limits, etc.)",
    "crumbs": [
      "Model Inputs"
    ]
  },
  {
    "objectID": "inputs.html#environmental-data-environment.nc",
    "href": "inputs.html#environmental-data-environment.nc",
    "title": "Model Inputs",
    "section": "",
    "text": "A NetCDF file containing spatial and temporal environmental variables for the model domain. It supports flexible dimensions and variable types.\n\n\n\n\n\n\n\n\nVariable\nDimensions\nDescription\n\n\n\n\ntemp\n4D\nFull water column temperature grid.\n\n\ntemp-surf\n3D\nSea surface temperature.\n\n\nsalinity\n3D or 4D\nSalinity values.\n\n\nchl\n3D\nSurface chlorophyll concentration.\n\n\nbathymetry\n2D\nSeafloor depth.\n\n\n\n\nThese input files form the backbone of your SwimmingIndividuals.jl simulation and allow extensive flexibility in configuring species traits, environmental drivers, and human impacts.",
    "crumbs": [
      "Model Inputs"
    ]
  },
  {
    "objectID": "components/utilities.html",
    "href": "components/utilities.html",
    "title": "SwimmingIndividuals.jl",
    "section": "",
    "text": "The utilities.jl file is the foundation of the model’s architecture. It defines all the core data structures that hold the simulation state, as well as a wide range of helper functions for tasks like spatial indexing, statistical calculations, and data loading.\n\n\nThis section defines the custom types (structs) that organize the model’s data.\n\nplankton & individuals: These structs are containers for the agent data. plankton holds the agent state variables (data) and the species-specific parameters (p), while individuals is a NamedTuple that holds all the plankton objects for the different focal species.\nFishery & Selectivity: These structs define the properties and regulations of a single fishery, including its quota, season, and the gear selectivity for each species it targets.\nMarineEnvironment & MarineDepths: These structs hold all the environmental data, including the multi-dimensional grids loaded from the NetCDF file and the vertical distribution profiles for the agents.\nMarineModel: This is the central, top-level struct that contains the entire state of the simulation, bringing all the other components together in one object.\n\n# ===================================================================\n# Core Data Structures\n# ===================================================================\n\n# Struct for a single species' agents and parameters\nmutable struct plankton\n    data::AbstractArray\n    p::NamedTuple\nend\n\n# Container for all focal species\nstruct individuals\n    animals::NamedTuple\nend\n\n# Temporary container for prey information during search\nmutable struct PreyInfo\n    Predator::Int\n    Sp::Int\n    Ind::Int\n    Type::Int\n    Length::Float64\n    Biomass::Float64\n    Distance::Float64\nend\n\n# Defines the gear selectivity for a species within a fishery\nstruct Selectivity\n    species::String\n    L50::Float64\n    slope::Float64\nend\n\n# Defines a single fishery's regulations and properties\nmutable struct Fishery\n    name::String\n    target_species::Vector{String}\n    bycatch_species::Vector{String}\n    selectivities::Dict{String, Selectivity}\n    quota::Float64\n    cumulative_catch::Float64\n    cumulative_inds::Int64\n    season::Tuple{Int, Int}\n    area::Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}, Tuple{Float64, Float64}}\n    slot_limit::Tuple{Float64, Float64}\n    bag_limit::Int64\nend\n\n# A flexible struct to hold any environmental data loaded from a NetCDF file\nmutable struct MarineEnvironment\n    data::Dict{String, AbstractArray}\n    ts::Int # To hold the current month index\nend\n\n# Holds vertical distribution data for agents\nmutable struct MarineDepths\n    focal_day::DataFrame\n    focal_night::DataFrame \n    patch_day::DataFrame\n    patch_night::DataFrame\n    grid::DataFrame\nend\n\n# The main model struct, containing the entire state of the simulation\nmutable struct MarineModel\n    arch::Architecture\n    environment::MarineEnvironment\n    depths::MarineDepths\n    fishing::Vector{Fishery}\n    t::Float64\n    iteration::Int64\n    dt::Float64\n    individuals::individuals\n    resources::NamedTuple{(:biomass, :capacity), Tuple{AbstractArray{Float64, 4}, AbstractArray{Float64, 4}}}\n    resource_trait::DataFrame\n    capacities::AbstractArray\n    ninds::Int64\n    n_species::Int64\n    n_resource::Int64\n    abund::Vector{Int64}\n    bioms::Vector{Float64}\n    init_abund::Vector{Int64}\n    files::DataFrame\n    output_dt::Int64\n    spinup::Int64\nend\n\n\n\nThis section contains a variety of helper functions that perform common tasks throughout the simulation.\nSpatial Indexing Helpers: get_cell_id and get_cell_xyz are fast, inline functions for converting between 3D grid coordinates and a single linear index, which is essential for efficient GPU operations.\nStatistical and Distribution Helpers: These functions handle statistical calculations, such as gaussmix for sampling from a multi-modal normal distribution (used for vertical positioning) and lognormal_params_from_maxsize for generating realistic size distributions for agents.\nGeometric and Distance Helpers: The haversine function calculates the great-circle distance between two geographic points.\nData Loading Helpers: generate_depths reads the various CSV files that define the vertical distribution profiles for the agents.\nPhysical Model Helpers: The ipar_curve function calculates the surface light intensity based on the time of day, creating a realistic diurnal light cycle.\n# ===================================================================\n# Helper and Utility Functions\n# ===================================================================\n\n# --- Spatial Indexing Helpers ---\n@inline function get_cell_id(x, y, z, lonres, latres)\n    return x + (y - 1) * lonres + (z - 1) * lonres * latres\nend\n\n@inline function get_cell_xyz(id, lonres, latres)\n    z = div(id - 1, lonres * latres) + 1\n    rem_id = (id - 1) % (lonres * latres)\n    y = div(rem_id, lonres) + 1\n    x = rem_id % lonres + 1\n    return x, y, z\nend\n\n# --- Statistical and Distribution Helpers ---\nfunction gaussmix(n, m1, m2, m3, s1, s2, s3, l1, l2)\n    I = rand(n) .&lt; l1\n    I2 = rand(n) .&lt; l1 .+ l2\n    z = [rand(I[i] ? Normal(m1, s1) : (I2[i] ? Normal(m2, s2) : Normal(m3, s3))) for i in 1:n]\n    return z\nend\n\nfunction multimodal_distribution(x, means, stds, weights)\n    pdf_values = [weights[i] * pdf(Normal(means[i], stds[i]), x) for i in 1:length(means)]\n    return sum(pdf_values)\nend\n\nfunction get_target_z(sp, dist)\n    return gaussmix(1, dist[sp, \"mu1\"], dist[sp, \"mu2\"], dist[sp, \"mu3\"], dist[sp, \"sigma1\"], dist[sp, \"sigma2\"], dist[sp, \"sigma3\"], dist[sp, \"lambda1\"], dist[sp, \"lambda2\"])[1]\nend\n\nfunction lognormal_params_from_maxsize(max_size::Real)\n    median_val = 1/3 * max_size\n    percentile = 0.95\n    μ = log(median_val)\n    z_score = quantile(Normal(0, 1), percentile)\n    σ = (log(max_size) - μ) / z_score\n    return μ, σ\nend\n\nfunction lognormal_params_from_minmax(min_size::Real, max_size::Real)\n    min_size = max(min_size, 1e-6)\n    if min_size &gt;= max_size; max_size = min_size * 1.1; end\n    log_min, log_max = log(min_size), log(max_size)\n    z = 1.96\n    μ = (log_max + log_min) / 2.0\n    σ = (log_max - log_min) / (2.0 * z)\n    return μ, σ\nend\n\n# --- Geometric and Distance Helpers ---\nfunction haversine(lat1, lon1, lat2, lon2)\n    R = 6371000.0 # Earth radius in meters\n    φ1, φ2 = deg2rad(lat1), deg2rad(lat2)\n    Δφ = deg2rad(lat2 - lat1)\n    Δλ = deg2rad(lon2 - lon1)\n    a = sin(Δφ/2)^2 + cos(φ1) * cos(φ2) * sin(Δλ/2)^2\n    c = 2 * atan(sqrt(a), sqrt(1 - a))\n    return R * c\nend\n\n# --- Data Loading and Initialization Helpers ---\nfunction generate_depths(files)\n    focal_day = CSV.read(files[files.File .== \"focal_z_dist_day\", :Destination][1], DataFrame)\n    focal_night = CSV.read(files[files.File .== \"focal_z_dist_night\", :Destination][1], DataFrame)\n    resource_day = CSV.read(files[files.File .== \"resource_z_dist_day\", :Destination][1], DataFrame)\n    resource_night = CSV.read(files[files.File .== \"resource_z_dist_night\", :Destination][1], DataFrame)\n    grid = CSV.read(files[files.File .== \"grid\",:Destination][1], DataFrame)\n    return MarineDepths(focal_day, focal_night, resource_day, resource_night, grid)\nend\n\nfunction load_ascii_raster(file_path::String)\n    open(file_path, \"r\") do f\n        header = Dict{String, Float64}()\n        for _ in 1:6\n            line = readline(f)\n            key, val = split(line)\n            header[key] = parse(Float64, val)\n        end\n        data = readdlm(f)\n        return data\n    end\nend\n\n# --- Physical Model Helpers ---\nfunction ipar_curve(time, peak_ipar=450, peak_time=12, width=4)\n    adj_time = time/60\n    return peak_ipar * exp(-((adj_time - peak_time)^2) / (2 * width^2))\nend",
    "crumbs": [
      "Model Components",
      "Model Utilities & Helpers"
    ]
  },
  {
    "objectID": "components/utilities.html#model-utilities-helpers",
    "href": "components/utilities.html#model-utilities-helpers",
    "title": "SwimmingIndividuals.jl",
    "section": "",
    "text": "The utilities.jl file is the foundation of the model’s architecture. It defines all the core data structures that hold the simulation state, as well as a wide range of helper functions for tasks like spatial indexing, statistical calculations, and data loading.\n\n\nThis section defines the custom types (structs) that organize the model’s data.\n\nplankton & individuals: These structs are containers for the agent data. plankton holds the agent state variables (data) and the species-specific parameters (p), while individuals is a NamedTuple that holds all the plankton objects for the different focal species.\nFishery & Selectivity: These structs define the properties and regulations of a single fishery, including its quota, season, and the gear selectivity for each species it targets.\nMarineEnvironment & MarineDepths: These structs hold all the environmental data, including the multi-dimensional grids loaded from the NetCDF file and the vertical distribution profiles for the agents.\nMarineModel: This is the central, top-level struct that contains the entire state of the simulation, bringing all the other components together in one object.\n\n# ===================================================================\n# Core Data Structures\n# ===================================================================\n\n# Struct for a single species' agents and parameters\nmutable struct plankton\n    data::AbstractArray\n    p::NamedTuple\nend\n\n# Container for all focal species\nstruct individuals\n    animals::NamedTuple\nend\n\n# Temporary container for prey information during search\nmutable struct PreyInfo\n    Predator::Int\n    Sp::Int\n    Ind::Int\n    Type::Int\n    Length::Float64\n    Biomass::Float64\n    Distance::Float64\nend\n\n# Defines the gear selectivity for a species within a fishery\nstruct Selectivity\n    species::String\n    L50::Float64\n    slope::Float64\nend\n\n# Defines a single fishery's regulations and properties\nmutable struct Fishery\n    name::String\n    target_species::Vector{String}\n    bycatch_species::Vector{String}\n    selectivities::Dict{String, Selectivity}\n    quota::Float64\n    cumulative_catch::Float64\n    cumulative_inds::Int64\n    season::Tuple{Int, Int}\n    area::Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}, Tuple{Float64, Float64}}\n    slot_limit::Tuple{Float64, Float64}\n    bag_limit::Int64\nend\n\n# A flexible struct to hold any environmental data loaded from a NetCDF file\nmutable struct MarineEnvironment\n    data::Dict{String, AbstractArray}\n    ts::Int # To hold the current month index\nend\n\n# Holds vertical distribution data for agents\nmutable struct MarineDepths\n    focal_day::DataFrame\n    focal_night::DataFrame \n    patch_day::DataFrame\n    patch_night::DataFrame\n    grid::DataFrame\nend\n\n# The main model struct, containing the entire state of the simulation\nmutable struct MarineModel\n    arch::Architecture\n    environment::MarineEnvironment\n    depths::MarineDepths\n    fishing::Vector{Fishery}\n    t::Float64\n    iteration::Int64\n    dt::Float64\n    individuals::individuals\n    resources::NamedTuple{(:biomass, :capacity), Tuple{AbstractArray{Float64, 4}, AbstractArray{Float64, 4}}}\n    resource_trait::DataFrame\n    capacities::AbstractArray\n    ninds::Int64\n    n_species::Int64\n    n_resource::Int64\n    abund::Vector{Int64}\n    bioms::Vector{Float64}\n    init_abund::Vector{Int64}\n    files::DataFrame\n    output_dt::Int64\n    spinup::Int64\nend\n\n\n\nThis section contains a variety of helper functions that perform common tasks throughout the simulation.\nSpatial Indexing Helpers: get_cell_id and get_cell_xyz are fast, inline functions for converting between 3D grid coordinates and a single linear index, which is essential for efficient GPU operations.\nStatistical and Distribution Helpers: These functions handle statistical calculations, such as gaussmix for sampling from a multi-modal normal distribution (used for vertical positioning) and lognormal_params_from_maxsize for generating realistic size distributions for agents.\nGeometric and Distance Helpers: The haversine function calculates the great-circle distance between two geographic points.\nData Loading Helpers: generate_depths reads the various CSV files that define the vertical distribution profiles for the agents.\nPhysical Model Helpers: The ipar_curve function calculates the surface light intensity based on the time of day, creating a realistic diurnal light cycle.\n# ===================================================================\n# Helper and Utility Functions\n# ===================================================================\n\n# --- Spatial Indexing Helpers ---\n@inline function get_cell_id(x, y, z, lonres, latres)\n    return x + (y - 1) * lonres + (z - 1) * lonres * latres\nend\n\n@inline function get_cell_xyz(id, lonres, latres)\n    z = div(id - 1, lonres * latres) + 1\n    rem_id = (id - 1) % (lonres * latres)\n    y = div(rem_id, lonres) + 1\n    x = rem_id % lonres + 1\n    return x, y, z\nend\n\n# --- Statistical and Distribution Helpers ---\nfunction gaussmix(n, m1, m2, m3, s1, s2, s3, l1, l2)\n    I = rand(n) .&lt; l1\n    I2 = rand(n) .&lt; l1 .+ l2\n    z = [rand(I[i] ? Normal(m1, s1) : (I2[i] ? Normal(m2, s2) : Normal(m3, s3))) for i in 1:n]\n    return z\nend\n\nfunction multimodal_distribution(x, means, stds, weights)\n    pdf_values = [weights[i] * pdf(Normal(means[i], stds[i]), x) for i in 1:length(means)]\n    return sum(pdf_values)\nend\n\nfunction get_target_z(sp, dist)\n    return gaussmix(1, dist[sp, \"mu1\"], dist[sp, \"mu2\"], dist[sp, \"mu3\"], dist[sp, \"sigma1\"], dist[sp, \"sigma2\"], dist[sp, \"sigma3\"], dist[sp, \"lambda1\"], dist[sp, \"lambda2\"])[1]\nend\n\nfunction lognormal_params_from_maxsize(max_size::Real)\n    median_val = 1/3 * max_size\n    percentile = 0.95\n    μ = log(median_val)\n    z_score = quantile(Normal(0, 1), percentile)\n    σ = (log(max_size) - μ) / z_score\n    return μ, σ\nend\n\nfunction lognormal_params_from_minmax(min_size::Real, max_size::Real)\n    min_size = max(min_size, 1e-6)\n    if min_size &gt;= max_size; max_size = min_size * 1.1; end\n    log_min, log_max = log(min_size), log(max_size)\n    z = 1.96\n    μ = (log_max + log_min) / 2.0\n    σ = (log_max - log_min) / (2.0 * z)\n    return μ, σ\nend\n\n# --- Geometric and Distance Helpers ---\nfunction haversine(lat1, lon1, lat2, lon2)\n    R = 6371000.0 # Earth radius in meters\n    φ1, φ2 = deg2rad(lat1), deg2rad(lat2)\n    Δφ = deg2rad(lat2 - lat1)\n    Δλ = deg2rad(lon2 - lon1)\n    a = sin(Δφ/2)^2 + cos(φ1) * cos(φ2) * sin(Δλ/2)^2\n    c = 2 * atan(sqrt(a), sqrt(1 - a))\n    return R * c\nend\n\n# --- Data Loading and Initialization Helpers ---\nfunction generate_depths(files)\n    focal_day = CSV.read(files[files.File .== \"focal_z_dist_day\", :Destination][1], DataFrame)\n    focal_night = CSV.read(files[files.File .== \"focal_z_dist_night\", :Destination][1], DataFrame)\n    resource_day = CSV.read(files[files.File .== \"resource_z_dist_day\", :Destination][1], DataFrame)\n    resource_night = CSV.read(files[files.File .== \"resource_z_dist_night\", :Destination][1], DataFrame)\n    grid = CSV.read(files[files.File .== \"grid\",:Destination][1], DataFrame)\n    return MarineDepths(focal_day, focal_night, resource_day, resource_night, grid)\nend\n\nfunction load_ascii_raster(file_path::String)\n    open(file_path, \"r\") do f\n        header = Dict{String, Float64}()\n        for _ in 1:6\n            line = readline(f)\n            key, val = split(line)\n            header[key] = parse(Float64, val)\n        end\n        data = readdlm(f)\n        return data\n    end\nend\n\n# --- Physical Model Helpers ---\nfunction ipar_curve(time, peak_ipar=450, peak_time=12, width=4)\n    adj_time = time/60\n    return peak_ipar * exp(-((adj_time - peak_time)^2) / (2 * width^2))\nend",
    "crumbs": [
      "Model Components",
      "Model Utilities & Helpers"
    ]
  },
  {
    "objectID": "components/predation.html",
    "href": "components/predation.html",
    "title": "SwimmingIndividuals.jl",
    "section": "",
    "text": "The predation.jl file contains all the functions that govern how agents find, select, and consume prey. This is one of the most computationally intensive parts of the model and is divided into three distinct systems: a spatial index for fast searching, a detailed agent-on-agent predation model, and a background predation model for diffuse resources.\n\n\nTo make the process of finding nearby prey efficient, especially on the GPU, the model first builds a spatial index at the beginning of each timestep. This process sorts all agents based on their grid cell location.\n\n\nThis function orchestrates the creation of the spatial index. It first calls a GPU kernel (assign_cell_ids_kernel!) to assign a unique linear ID to each agent based on its (pool_x, pool_y, pool_z) coordinates. It then performs a high-speed sort on these IDs. Finally, it uses a parallel prefix scan algorithm (thrust.searchsortedfirst on the GPU) to find the start and end indices in the sorted array that correspond to each grid cell. This creates a set of pointers (cell_starts, cell_ends) that allow kernels to perform very fast, localized searches by only looking at agents within a specific grid cell.\n# ===================================================================\n# Spatial Indexing System\n# ===================================================================\n\n# Kernel to assign a cell_id to each agent based on its grid location\n@kernel function assign_cell_ids_kernel!(agents, lonres, latres)\n    i = @index(Global)\n    @inbounds agents.cell_id[i] = get_cell_id(agents.pool_x[i], agents.pool_y[i], agents.pool_z[i], lonres, latres)\nend\n\n\"\"\"\nBuilds the spatial index for all species. This should be called once per timestep.\nIt sorts agents by their location for fast neighborhood searches.\n\"\"\"\nfunction build_spatial_index!(model::MarineModel)\n    arch = model.arch\n    g = model.depths.grid\n    lonres = Int(g[g.Name .== \"lonres\", :Value][1])\n    latres = Int(g[g.Name .== \"latres\", :Value][1])\n    depthres = Int(g[g.Name .== \"depthres\", :Value][1])\n    n_cells = lonres * latres * depthres\n\n    for sp in 1:model.n_species\n        agents = model.individuals.animals[sp].data\n        n_agents = length(agents.x)\n        if n_agents == 0; continue; end\n\n        if length(agents.cell_starts) &lt; n_cells\n            @error \"The pre-allocated 'cell_starts' array is too small for the grid size.\"\n            return\n        end\n\n        kernel_assign = assign_cell_ids_kernel!(device(arch), 256, (n_agents,))\n        kernel_assign(agents, lonres, latres)\n        \n        sortperm!(agents.sorted_id, agents.cell_id)\n        \n        if arch isa GPU\n            sorted_cell_ids = agents.cell_id[agents.sorted_id]\n            cell_range = array_type(arch)(1:n_cells)\n            cell_starts_gpu = thrust.searchsortedfirst(sorted_cell_ids, cell_range)\n            \n            cell_ends_gpu = similar(cell_starts_gpu)\n            if n_cells &gt; 1\n                cell_ends_gpu[1:end-1] .= cell_starts_gpu[2:end] .- 1\n            end\n            cell_ends_gpu[end] = n_agents\n            \n            copyto!(@view(agents.cell_starts[1:n_cells]), cell_starts_gpu)\n            copyto!(@view(agents.cell_ends[1:n_cells]), cell_ends_gpu)\n        else\n            sorted_cell_ids_cpu = agents.cell_id[agents.sorted_id]\n            cell_starts_cpu = ones(Int, n_cells)\n            cell_ends_cpu = zeros(Int, n_cells)\n            \n            if !isempty(sorted_cell_ids_cpu)\n                for i in 2:n_agents\n                    if sorted_cell_ids_cpu[i] != sorted_cell_ids_cpu[i-1]\n                        cell_starts_cpu[sorted_cell_ids_cpu[i]] = i\n                        cell_ends_cpu[sorted_cell_ids_cpu[i-1]] = i - 1\n                    end\n                end\n                cell_ends_cpu[sorted_cell_ids_cpu[end]] = n_agents\n            end\n            \n            copyto!(@view(agents.cell_starts[1:n_cells]), cell_starts_cpu)\n            copyto!(@view(agents.cell_ends[1:n_cells]), cell_ends_cpu)\n        end\n    end\nend\n\n\n\n\nThis system models direct predation between focal species agents and their consumption of the resource grid. It uses a three-step process to handle the complex, parallel interactions efficiently and safely.\n\n\nThis is the launcher for the first step. It prepares all the necessary data (agent data, prey data, resource grids, trait parameters) and then calls the find_best_prey_kernel! to run on the GPU.\nThe find_best_prey_kernel! is where each predator “records” its intent to eat. Each predator agent searches its local 3x3x3 grid neighborhood for all possible prey (both other agents and resource grid cells). It evaluates each potential prey based on its size preference and distance. The single best target (the closest, suitably-sized prey) is recorded for each predator. This process uses atomic operations (atomic_cas!) to ensure that multiple threads can safely write their findings without interfering with each other.\n\n\n\nThis function is the second step and acts as a “referee.” It runs on the CPU. It gathers the “intent to eat” records from all predators and resolves any conflicts that arise when multiple predators have targeted the same prey. It ensures that the biomass of a single prey is not over-consumed, allocating the available biomass among the competing predators. The result of this process is a successful_ration for each predator.\n\n\n\nThis is the final step. The launcher function deconstructs all the necessary data and passes it to the apply_consumption_kernel!. This GPU kernel runs over all predators and “applies” the successful_ration that was determined by the referee. It updates the state of both the predator (increasing its ration and gut fullness) and the prey (decreasing its biomass and abundance).\n# ===================================================================\n# Agent-on-Agent Predation System (\"Record-and-Resolve\")\n# ===================================================================\n\n@kernel function find_best_prey_kernel!(\n    best_prey_dist, best_prey_idx, best_prey_sp, best_prey_type,\n    pred_data, prey_data_all, resource_biomass_grid, resource_trait,\n    pred_inds, grid_params, pred_params\n)\n    j_idx = @index(Global)\n    pred_idx = pred_inds[j_idx]\n\n    @inbounds if pred_data.alive[pred_idx] == 1.0\n        my_x, my_y, my_z = pred_data.x[pred_idx], pred_data.y[pred_idx], pred_data.z[pred_idx]\n        my_pool_x, my_pool_y, my_pool_z = pred_data.pool_x[pred_idx], pred_data.pool_y[pred_idx], pred_data.pool_z[pred_idx]\n        min_size = pred_data.length[pred_idx] * pred_params.min_prey_ratio\n        max_size = pred_data.length[pred_idx] * pred_params.max_prey_ratio\n        detection_radius_sq = pred_data.vis_prey[pred_idx]^2\n\n        for dz in -1:1, dy in -1:1, dx in -1:1\n            search_x = my_pool_x + dx\n            search_y = my_pool_y + dy\n            search_z = my_pool_z + dz\n\n            if 1 &lt;= search_x &lt;= grid_params.lonres && 1 &lt;= search_y &lt;= grid_params.latres && 1 &lt;= search_z &lt;= grid_params.depthres\n                for prey_sp_idx in 1:length(prey_data_all)\n                    prey_data = prey_data_all[prey_sp_idx]\n                    for k in 1:length(prey_data.x)\n                        @inbounds if prey_data.alive[k] == 1.0 && min_size &lt;= prey_data.length[k] &lt;= max_size\n                            dist_sq = (my_x - prey_data.x[k])^2 + (my_y - prey_data.y[k])^2 + (my_z - prey_data.z[k])^2\n                            if dist_sq &lt;= detection_radius_sq && dist_sq &lt; best_prey_dist[pred_idx]\n                                old_dist = atomic_cas!(pointer(best_prey_dist, pred_idx), best_prey_dist[pred_idx], Float32(dist_sq))\n                                if old_dist &gt;= best_prey_dist[pred_idx]\n                                    best_prey_idx[pred_idx] = k\n                                    best_prey_sp[pred_idx] = prey_sp_idx\n                                    best_prey_type[pred_idx] = 1\n                                end\n                            end\n                        end\n                    end\n                end\n                \n                for res_sp in 1:size(resource_biomass_grid, 4)\n                    biomass_density = resource_biomass_grid[search_x, search_y, search_z, res_sp]\n                    if biomass_density &gt; 0\n                        res_min = resource_trait.Min_Size[res_sp]\n                        res_max = resource_trait.Max_Size[res_sp]\n                        μ, σ = lognormal_params_from_minmax(res_min, res_max)\n                        mean_size = exp(μ + 0.5 * σ^2)\n                        if min_size &lt;= mean_size &lt;= max_size\n                            prey_grid_x = grid_params.lon_min + (search_x - 0.5) * grid_params.cell_size_deg\n                            prey_grid_y = grid_params.lat_min + (search_y - 0.5) * grid_params.cell_size_deg\n                            prey_grid_z = (search_z - 0.5) * grid_params.depth_res_m\n                            dist_sq = (my_x - prey_grid_x)^2 + (my_y - prey_grid_y)^2 + (my_z - prey_grid_z)^2\n                            if dist_sq &lt;= detection_radius_sq && dist_sq &lt; best_prey_dist[pred_idx]\n                                linear_idx = search_x + (search_y-1)*grid_params.lonres + (search_z-1)*grid_params.lonres*grid_params.latres\n                                old_dist = atomic_cas!(pointer(best_prey_dist, pred_idx), best_prey_dist[pred_idx], Float32(dist_sq))\n                                if old_dist &gt;= best_prey_dist[pred_idx]\n                                    best_prey_idx[pred_idx] = linear_idx\n                                    best_prey_sp[pred_idx] = res_sp\n                                    best_prey_type[pred_idx] = 2\n                                end\n                            end\n                        end\n                    end\n                end\n            end\n        end\n    end\nend\n\nfunction calculate_distances_prey!(model::MarineModel, sp::Int, inds::Vector{Int})\n    arch = model.arch\n    pred_data = model.individuals.animals[sp].data\n    pred_params = (min_prey_ratio = model.individuals.animals[sp].p.Min_Prey[2][sp], max_prey_ratio = model.individuals.animals[sp].p.Max_Prey[2][sp])\n    grid = model.depths.grid\n    grid_params = (\n        lonres = Int(grid[grid.Name .== \"lonres\", :Value][1]), latres = Int(grid[grid.Name .== \"latres\", :Value][1]),\n        depthres = Int(grid[grid.Name .== \"depthres\", :Value][1]), lon_min = grid[grid.Name .== \"xllcorner\", :Value][1],\n        lat_min = grid[grid.Name .== \"yllcorner\", :Value][1], cell_size_deg = grid[grid.Name .== \"cellsize\", :Value][1],\n        depth_res_m = grid[grid.Name .== \"depthmax\", :Value][1] / Int(grid[grid.Name .== \"depthres\", :Value][1])\n    )\n    trait_df = model.resource_trait\n    resource_trait_gpu = (; (Symbol(c) =&gt; array_type(arch)(trait_df[:, c]) for c in names(trait_df))...)\n    fill!(pred_data.best_prey_dist, Inf32); fill!(pred_data.best_prey_idx, 0);\n    fill!(pred_data.best_prey_sp, 0); fill!(pred_data.best_prey_type, 0)\n    prey_data_all = Tuple(animal.data for animal in model.individuals.animals)\n    kernel! = find_best_prey_kernel!(device(arch), 256, (length(inds),))\n    kernel!(\n        pred_data.best_prey_dist, pred_data.best_prey_idx, pred_data.best_prey_sp, pred_data.best_prey_type,\n        pred_data, prey_data_all, model.resources.biomass, resource_trait_gpu,\n        array_type(arch)(inds), grid_params, pred_params\n    )\n    KernelAbstractions.synchronize(device(arch))\n    return nothing\nend\n\nfunction resolve_consumption!(model::MarineModel, sp::Int, to_eat::Vector{Int})\n    pred_data = model.individuals.animals[sp].data\n    best_prey_idx_cpu = Array(pred_data.best_prey_idx[to_eat]); best_prey_sp_cpu = Array(pred_data.best_prey_sp[to_eat]);\n    best_prey_type_cpu = Array(pred_data.best_prey_type[to_eat]); pred_biomass_cpu = Array(pred_data.biomass_school[to_eat]);\n    pred_gut_full_cpu = Array(pred_data.gut_fullness[to_eat]);\n    prey_biomass_all_cpu = [Array(animal.data.biomass_school) for animal in model.individuals.animals]\n    res_biomass_cpu = Array(model.resources.biomass)\n    successful_rations_cpu = zeros(Float64, length(pred_data.x))\n    prey_claimed = Dict{Tuple{Int, Int}, Float64}()\n    for i in 1:length(to_eat)\n        pred_idx = to_eat[i]; prey_idx = best_prey_idx_cpu[i]\n        if prey_idx == 0; continue; end\n        prey_sp = best_prey_sp_cpu[i]; prey_type = best_prey_type_cpu[i]\n        prey_key = (prey_type, prey_idx)\n        claimed_biomass = get(prey_claimed, prey_key, 0.0)\n        total_biomass = (prey_type == 1) ? prey_biomass_all_cpu[prey_sp][prey_idx] : res_biomass_cpu[prey_idx]\n        available_biomass = total_biomass - claimed_biomass\n        if available_biomass &lt;= 0; continue; end\n        max_stomach = 0.2 * pred_biomass_cpu[i]\n        current_stomach = pred_gut_full_cpu[i] * pred_biomass_cpu[i]\n        stomach_space = max(0.0, max_stomach - current_stomach)\n        ration = min(available_biomass, stomach_space)\n        if ration &gt; 0\n            successful_rations_cpu[pred_idx] = ration\n            prey_claimed[prey_key] = get(prey_claimed, prey_key, 0.0) + ration\n        end\n    end\n    copyto!(@view(pred_data.successful_ration[1:end]), successful_rations_cpu)\nend\n\n@kernel function apply_consumption_kernel!(\n    alive, best_prey_dist, best_prey_idx, best_prey_sp, best_prey_type,\n    x, y, z, pool_x, pool_y, pool_z, length_arr, biomass_school, gut_fullness,\n    ration, active, successful_ration,\n    prey_data_all, resource_biomass_grid,\n    pred_chars, time, grid_params, sp\n)\n    pred_idx = @index(Global)\n    @inbounds if alive[pred_idx] == 1.0\n        s_ration = successful_ration[pred_idx]\n        if s_ration &gt; 0.0\n            dist = sqrt(best_prey_dist[pred_idx])\n            time_left = time[pred_idx]\n            swim_velo = pred_chars.Swim_velo[sp] * (length_arr[pred_idx] / 1000.0)\n            time_to_prey = swim_velo &gt; 0 ? dist / swim_velo : Inf32\n\n            if time_to_prey &lt; time_left\n                time_left -= time_to_prey\n                @atomic active[pred_idx] += time_to_prey / 60.0\n                handling_time = pred_chars.Handling_Time[sp]\n                num_can_handle = handling_time &gt; 0 ? floor(Int, time_left / handling_time) : 0\n                time_spent_handling = num_can_handle * handling_time\n                @atomic ration[pred_idx] += s_ration\n                @atomic gut_fullness[pred_idx] += s_ration / biomass_school[pred_idx]\n                @atomic active[pred_idx] += time_spent_handling / 60.0\n                time[pred_idx] -= (time_to_prey + time_spent_handling)\n            else\n                @atomic active[pred_idx] += time_left / 60.0\n                time[pred_idx] = 0.0\n            end\n            successful_ration[pred_idx] = 0.0\n        end\n    end\nend\n\nfunction apply_consumption!(model::MarineModel, sp::Int, time::AbstractArray, outputs::MarineOutputs)\n    arch = model.arch\n    pred_data = model.individuals.animals[sp].data\n    pred_chars_gpu = (; (k =&gt; array_type(arch)(v.second) for (k, v) in pairs(model.individuals.animals[sp].p))...)\n    prey_data_all = Tuple(animal.data for animal in model.individuals.animals)\n    grid = model.depths.grid\n    grid_params = (\n        lonres = Int(grid[grid.Name .== \"lonres\", :Value][1]), latres = Int(grid[grid.Name .== \"latres\", :Value][1]),\n        depthres = Int(grid[grid.Name .== \"depthres\", :Value][1]), lon_min = grid[grid.Name .== \"xllcorner\", :Value][1],\n        lat_min = grid[grid.Name .== \"yllcorner\", :Value][1], cell_size_deg = grid[grid.Name .== \"cellsize\", :Value][1],\n        depth_res_m = grid[grid.Name .== \"depthmax\", :Value][1] / Int(grid[grid.Name .== \"depthres\", :Value][1])\n    )\n    kernel! = apply_consumption_kernel!(device(arch), 256, (length(pred_data.x),))\n    kernel!(\n        pred_data.alive, pred_data.best_prey_dist, pred_data.best_prey_idx, \n        pred_data.best_prey_sp, pred_data.best_prey_type,\n        pred_data.x, pred_data.y, pred_data.z, pred_data.pool_x, pred_data.pool_y, pred_data.pool_z,\n        pred_data.length, pred_data.biomass_school, pred_data.gut_fullness,\n        pred_data.ration, pred_data.active, pred_data.successful_ration,\n        prey_data_all, model.resources.biomass,\n        pred_chars_gpu, time, grid_params, sp\n    )\n    KernelAbstractions.synchronize(device(arch))\nend\n\n\n\n\nThis system models the mortality imposed on focal species by diffuse, un-modeled predators (e.g., zooplankton). It is a three-kernel process designed for the GPU.\n\n\nThis is the main launcher function. It first calls calculate_prey_biomass_kernel! to sum the biomass of all focal species agents into a 3D grid. It then calls calculate_mortality_rate_kernel!, which uses this prey grid and the resource predator grid (model.resources.biomass) to calculate a mortality rate in each cell based on a Holling Type II functional response. Finally, it launches a kernel for each prey species (apply_resource_mortality_kernel!) to apply this calculated mortality rate to the individual agents.\n# ===================================================================\n# Background Resource Predation System\n# ===================================================================\n\n@inline function resource_predation_mortality_device(\n    prey_biomass::Float64, pred_biomass::Float64, pred_weight::Float64,\n    daily_ration::Float64, handling_time::Float64, dt::Float64\n)\n    (prey_biomass &lt;= 0.0 || pred_biomass &lt;= 0.0) && return 0.0\n    N = prey_biomass / 1000.0\n    total_intake = (pred_biomass / 1000.0) * (daily_ration / 100.0)\n    total_intake &lt;= 0.0 && return 0.0\n    denominator = N - total_intake * handling_time * N\n    FR_day = (denominator &lt;= 1e-9) ? total_intake : (total_intake / denominator * N) / (1.0 + (total_intake / denominator) * handling_time * N)\n    FR_timestep = FR_day * (dt / 1440.0)\n    mortality = (FR_timestep * 1000.0) / prey_biomass\n    return clamp(mortality, 0.0, 1.0)\nend\n\n@kernel function calculate_prey_biomass_kernel!(prey_biomass_grid, animals_all)\n    i = @index(Global)\n    for sp in 1:length(animals_all)\n        animal = animals_all[sp]\n        if i &lt;= length(animal.x) && animal.alive[i] == 1.0\n            @atomic prey_biomass_grid[animal.pool_x[i], animal.pool_y[i], animal.pool_z[i], sp] += animal.biomass_school[i]\n        end\n    end\nend\n\n@kernel function calculate_mortality_rate_kernel!(mortality_rate_grid, pred_biomass_grid, prey_biomass_grid, resource_trait, dt, cell_area)\n    x, y, z, r = @index(Global, NTuple)\n    pred_biom = pred_biomass_grid[x, y, z, r] / cell_area\n    if pred_biom &gt; 0.0\n        min_prey_ratio = resource_trait.Min_Prey[r]\n        max_prey_ratio = resource_trait.Max_Prey[r]\n        max_ingestion = resource_trait.Daily_Ration[r]\n        handling_time = Float64(resource_trait.Handling_Time[r])\n        max_pred_size = resource_trait.Max_Size[r]\n        μ_pred, σ_pred = lognormal_params_from_maxsize(Int(max_pred_size))\n        pred_length_mean = exp(μ_pred + 0.5 * σ_pred^2)\n        pred_weight_mean = resource_trait.LWR_a[r] * (pred_length_mean / 10)^resource_trait.LWR_b[r]\n        \n        total_available_biomass = 0.0\n        for sp in 1:size(prey_biomass_grid, 4)\n            total_available_biomass += prey_biomass_grid[x, y, z, sp]\n        end\n\n        if total_available_biomass &gt; 0.0\n            for sp in 1:size(prey_biomass_grid, 4)\n                prey_biom = prey_biomass_grid[x, y, z, sp] / cell_area\n                if prey_biom &gt; 0\n                    prop_ingestion = (prey_biom / (total_available_biomass / cell_area)) * max_ingestion\n                    mortality_rate = resource_predation_mortality_device(prey_biom, pred_biom, pred_weight_mean, prop_ingestion, handling_time, dt)\n                    mortality_rate_grid[x, y, z, r, sp] = mortality_rate\n                end\n            end\n        end\n    end\nend\n\n@kernel function apply_resource_mortality_kernel!(animal_data, mortality_rate_grid, sp_idx)\n    i = @index(Global)\n    if i &lt;= length(animal_data.x) && animal_data.alive[i] == 1.0\n        x, y, z = animal_data.pool_x[i], animal_data.pool_y[i], animal_data.pool_z[i]\n        total_mortality_rate = 0.0\n        for r in 1:size(mortality_rate_grid, 4)\n            total_mortality_rate += mortality_rate_grid[x, y, z, r, sp_idx]\n        end\n        if total_mortality_rate &gt; 0\n            total_mortality_rate = min(total_mortality_rate, 1.0)\n            biomass_removed = animal_data.biomass_school[i] * total_mortality_rate\n            @atomic animal_data.biomass_school[i] -= biomass_removed\n            if animal_data.biomass_ind[i] &gt; 0\n                inds_removed = floor(Int, biomass_removed / animal_data.biomass_ind[i])\n                @atomic animal_data.abundance[i] -= Float64(inds_removed)\n            end\n            if animal_data.abundance[i] &lt;= 0; animal_data.alive[i] = 0.0; end\n        end\n    end\nend\n\nfunction resource_predation!(model::MarineModel, output::MarineOutputs)\n    arch = model.arch\n    g = model.depths.grid\n    lonres = Int(g[g.Name .== \"lonres\", :Value][1])\n    latres = Int(g[g.Name .== \"latres\", :Value][1])\n    depthres = Int(g[g.Name .== \"depthres\", :Value][1])\n    n_sp = model.n_species\n    n_res = model.n_resource\n    \n    trait_df = model.resource_trait\n    resource_trait_gpu = (; (Symbol(c) =&gt; array_type(arch)(trait_df[:, c]) for c in names(trait_df))...)\n\n    prey_biomass_grid = array_type(arch)(zeros(Float64, lonres, latres, depthres, n_sp))\n    mortality_rate_grid = array_type(arch)(zeros(Float32, lonres, latres, depthres, n_res, n_sp))\n    \n    animals_all = Tuple(animal.data for animal in model.individuals.animals)\n    cell_area = 1.0 # Placeholder\n\n    max_len = 0\n    if !isempty(animals_all)\n        max_len = maximum(length(a.x) for a in animals_all if !isempty(a.x))\n    end\n    \n    if max_len &gt; 0\n        kernel1 = calculate_prey_biomass_kernel!(device(arch), 256, (max_len,))\n        kernel1(prey_biomass_grid, animals_all)\n    end\n    \n    kernel2_ndrange = (lonres, latres, depthres, n_res)\n    kernel2 = calculate_mortality_rate_kernel!(device(arch), (8,8,4,1), kernel2_ndrange)\n    kernel2(mortality_rate_grid, model.resources.biomass, prey_biomass_grid, resource_trait_gpu, model.dt, cell_area)\n\n    for sp_idx in 1:n_sp\n        agents = model.individuals.animals[sp_idx].data\n        if length(agents.x) &gt; 0\n            kernel3 = apply_resource_mortality_kernel!(device(arch), 256, (length(agents.x),))\n            kernel3(agents, mortality_rate_grid, sp_idx)\n        end\n    end\n    \n    KernelAbstractions.synchronize(device(arch))\n    return nothing\nend",
    "crumbs": [
      "Model Components",
      "Predation Components"
    ]
  },
  {
    "objectID": "components/predation.html#predation-components",
    "href": "components/predation.html#predation-components",
    "title": "SwimmingIndividuals.jl",
    "section": "",
    "text": "The predation.jl file contains all the functions that govern how agents find, select, and consume prey. This is one of the most computationally intensive parts of the model and is divided into three distinct systems: a spatial index for fast searching, a detailed agent-on-agent predation model, and a background predation model for diffuse resources.\n\n\nTo make the process of finding nearby prey efficient, especially on the GPU, the model first builds a spatial index at the beginning of each timestep. This process sorts all agents based on their grid cell location.\n\n\nThis function orchestrates the creation of the spatial index. It first calls a GPU kernel (assign_cell_ids_kernel!) to assign a unique linear ID to each agent based on its (pool_x, pool_y, pool_z) coordinates. It then performs a high-speed sort on these IDs. Finally, it uses a parallel prefix scan algorithm (thrust.searchsortedfirst on the GPU) to find the start and end indices in the sorted array that correspond to each grid cell. This creates a set of pointers (cell_starts, cell_ends) that allow kernels to perform very fast, localized searches by only looking at agents within a specific grid cell.\n# ===================================================================\n# Spatial Indexing System\n# ===================================================================\n\n# Kernel to assign a cell_id to each agent based on its grid location\n@kernel function assign_cell_ids_kernel!(agents, lonres, latres)\n    i = @index(Global)\n    @inbounds agents.cell_id[i] = get_cell_id(agents.pool_x[i], agents.pool_y[i], agents.pool_z[i], lonres, latres)\nend\n\n\"\"\"\nBuilds the spatial index for all species. This should be called once per timestep.\nIt sorts agents by their location for fast neighborhood searches.\n\"\"\"\nfunction build_spatial_index!(model::MarineModel)\n    arch = model.arch\n    g = model.depths.grid\n    lonres = Int(g[g.Name .== \"lonres\", :Value][1])\n    latres = Int(g[g.Name .== \"latres\", :Value][1])\n    depthres = Int(g[g.Name .== \"depthres\", :Value][1])\n    n_cells = lonres * latres * depthres\n\n    for sp in 1:model.n_species\n        agents = model.individuals.animals[sp].data\n        n_agents = length(agents.x)\n        if n_agents == 0; continue; end\n\n        if length(agents.cell_starts) &lt; n_cells\n            @error \"The pre-allocated 'cell_starts' array is too small for the grid size.\"\n            return\n        end\n\n        kernel_assign = assign_cell_ids_kernel!(device(arch), 256, (n_agents,))\n        kernel_assign(agents, lonres, latres)\n        \n        sortperm!(agents.sorted_id, agents.cell_id)\n        \n        if arch isa GPU\n            sorted_cell_ids = agents.cell_id[agents.sorted_id]\n            cell_range = array_type(arch)(1:n_cells)\n            cell_starts_gpu = thrust.searchsortedfirst(sorted_cell_ids, cell_range)\n            \n            cell_ends_gpu = similar(cell_starts_gpu)\n            if n_cells &gt; 1\n                cell_ends_gpu[1:end-1] .= cell_starts_gpu[2:end] .- 1\n            end\n            cell_ends_gpu[end] = n_agents\n            \n            copyto!(@view(agents.cell_starts[1:n_cells]), cell_starts_gpu)\n            copyto!(@view(agents.cell_ends[1:n_cells]), cell_ends_gpu)\n        else\n            sorted_cell_ids_cpu = agents.cell_id[agents.sorted_id]\n            cell_starts_cpu = ones(Int, n_cells)\n            cell_ends_cpu = zeros(Int, n_cells)\n            \n            if !isempty(sorted_cell_ids_cpu)\n                for i in 2:n_agents\n                    if sorted_cell_ids_cpu[i] != sorted_cell_ids_cpu[i-1]\n                        cell_starts_cpu[sorted_cell_ids_cpu[i]] = i\n                        cell_ends_cpu[sorted_cell_ids_cpu[i-1]] = i - 1\n                    end\n                end\n                cell_ends_cpu[sorted_cell_ids_cpu[end]] = n_agents\n            end\n            \n            copyto!(@view(agents.cell_starts[1:n_cells]), cell_starts_cpu)\n            copyto!(@view(agents.cell_ends[1:n_cells]), cell_ends_cpu)\n        end\n    end\nend\n\n\n\n\nThis system models direct predation between focal species agents and their consumption of the resource grid. It uses a three-step process to handle the complex, parallel interactions efficiently and safely.\n\n\nThis is the launcher for the first step. It prepares all the necessary data (agent data, prey data, resource grids, trait parameters) and then calls the find_best_prey_kernel! to run on the GPU.\nThe find_best_prey_kernel! is where each predator “records” its intent to eat. Each predator agent searches its local 3x3x3 grid neighborhood for all possible prey (both other agents and resource grid cells). It evaluates each potential prey based on its size preference and distance. The single best target (the closest, suitably-sized prey) is recorded for each predator. This process uses atomic operations (atomic_cas!) to ensure that multiple threads can safely write their findings without interfering with each other.\n\n\n\nThis function is the second step and acts as a “referee.” It runs on the CPU. It gathers the “intent to eat” records from all predators and resolves any conflicts that arise when multiple predators have targeted the same prey. It ensures that the biomass of a single prey is not over-consumed, allocating the available biomass among the competing predators. The result of this process is a successful_ration for each predator.\n\n\n\nThis is the final step. The launcher function deconstructs all the necessary data and passes it to the apply_consumption_kernel!. This GPU kernel runs over all predators and “applies” the successful_ration that was determined by the referee. It updates the state of both the predator (increasing its ration and gut fullness) and the prey (decreasing its biomass and abundance).\n# ===================================================================\n# Agent-on-Agent Predation System (\"Record-and-Resolve\")\n# ===================================================================\n\n@kernel function find_best_prey_kernel!(\n    best_prey_dist, best_prey_idx, best_prey_sp, best_prey_type,\n    pred_data, prey_data_all, resource_biomass_grid, resource_trait,\n    pred_inds, grid_params, pred_params\n)\n    j_idx = @index(Global)\n    pred_idx = pred_inds[j_idx]\n\n    @inbounds if pred_data.alive[pred_idx] == 1.0\n        my_x, my_y, my_z = pred_data.x[pred_idx], pred_data.y[pred_idx], pred_data.z[pred_idx]\n        my_pool_x, my_pool_y, my_pool_z = pred_data.pool_x[pred_idx], pred_data.pool_y[pred_idx], pred_data.pool_z[pred_idx]\n        min_size = pred_data.length[pred_idx] * pred_params.min_prey_ratio\n        max_size = pred_data.length[pred_idx] * pred_params.max_prey_ratio\n        detection_radius_sq = pred_data.vis_prey[pred_idx]^2\n\n        for dz in -1:1, dy in -1:1, dx in -1:1\n            search_x = my_pool_x + dx\n            search_y = my_pool_y + dy\n            search_z = my_pool_z + dz\n\n            if 1 &lt;= search_x &lt;= grid_params.lonres && 1 &lt;= search_y &lt;= grid_params.latres && 1 &lt;= search_z &lt;= grid_params.depthres\n                for prey_sp_idx in 1:length(prey_data_all)\n                    prey_data = prey_data_all[prey_sp_idx]\n                    for k in 1:length(prey_data.x)\n                        @inbounds if prey_data.alive[k] == 1.0 && min_size &lt;= prey_data.length[k] &lt;= max_size\n                            dist_sq = (my_x - prey_data.x[k])^2 + (my_y - prey_data.y[k])^2 + (my_z - prey_data.z[k])^2\n                            if dist_sq &lt;= detection_radius_sq && dist_sq &lt; best_prey_dist[pred_idx]\n                                old_dist = atomic_cas!(pointer(best_prey_dist, pred_idx), best_prey_dist[pred_idx], Float32(dist_sq))\n                                if old_dist &gt;= best_prey_dist[pred_idx]\n                                    best_prey_idx[pred_idx] = k\n                                    best_prey_sp[pred_idx] = prey_sp_idx\n                                    best_prey_type[pred_idx] = 1\n                                end\n                            end\n                        end\n                    end\n                end\n                \n                for res_sp in 1:size(resource_biomass_grid, 4)\n                    biomass_density = resource_biomass_grid[search_x, search_y, search_z, res_sp]\n                    if biomass_density &gt; 0\n                        res_min = resource_trait.Min_Size[res_sp]\n                        res_max = resource_trait.Max_Size[res_sp]\n                        μ, σ = lognormal_params_from_minmax(res_min, res_max)\n                        mean_size = exp(μ + 0.5 * σ^2)\n                        if min_size &lt;= mean_size &lt;= max_size\n                            prey_grid_x = grid_params.lon_min + (search_x - 0.5) * grid_params.cell_size_deg\n                            prey_grid_y = grid_params.lat_min + (search_y - 0.5) * grid_params.cell_size_deg\n                            prey_grid_z = (search_z - 0.5) * grid_params.depth_res_m\n                            dist_sq = (my_x - prey_grid_x)^2 + (my_y - prey_grid_y)^2 + (my_z - prey_grid_z)^2\n                            if dist_sq &lt;= detection_radius_sq && dist_sq &lt; best_prey_dist[pred_idx]\n                                linear_idx = search_x + (search_y-1)*grid_params.lonres + (search_z-1)*grid_params.lonres*grid_params.latres\n                                old_dist = atomic_cas!(pointer(best_prey_dist, pred_idx), best_prey_dist[pred_idx], Float32(dist_sq))\n                                if old_dist &gt;= best_prey_dist[pred_idx]\n                                    best_prey_idx[pred_idx] = linear_idx\n                                    best_prey_sp[pred_idx] = res_sp\n                                    best_prey_type[pred_idx] = 2\n                                end\n                            end\n                        end\n                    end\n                end\n            end\n        end\n    end\nend\n\nfunction calculate_distances_prey!(model::MarineModel, sp::Int, inds::Vector{Int})\n    arch = model.arch\n    pred_data = model.individuals.animals[sp].data\n    pred_params = (min_prey_ratio = model.individuals.animals[sp].p.Min_Prey[2][sp], max_prey_ratio = model.individuals.animals[sp].p.Max_Prey[2][sp])\n    grid = model.depths.grid\n    grid_params = (\n        lonres = Int(grid[grid.Name .== \"lonres\", :Value][1]), latres = Int(grid[grid.Name .== \"latres\", :Value][1]),\n        depthres = Int(grid[grid.Name .== \"depthres\", :Value][1]), lon_min = grid[grid.Name .== \"xllcorner\", :Value][1],\n        lat_min = grid[grid.Name .== \"yllcorner\", :Value][1], cell_size_deg = grid[grid.Name .== \"cellsize\", :Value][1],\n        depth_res_m = grid[grid.Name .== \"depthmax\", :Value][1] / Int(grid[grid.Name .== \"depthres\", :Value][1])\n    )\n    trait_df = model.resource_trait\n    resource_trait_gpu = (; (Symbol(c) =&gt; array_type(arch)(trait_df[:, c]) for c in names(trait_df))...)\n    fill!(pred_data.best_prey_dist, Inf32); fill!(pred_data.best_prey_idx, 0);\n    fill!(pred_data.best_prey_sp, 0); fill!(pred_data.best_prey_type, 0)\n    prey_data_all = Tuple(animal.data for animal in model.individuals.animals)\n    kernel! = find_best_prey_kernel!(device(arch), 256, (length(inds),))\n    kernel!(\n        pred_data.best_prey_dist, pred_data.best_prey_idx, pred_data.best_prey_sp, pred_data.best_prey_type,\n        pred_data, prey_data_all, model.resources.biomass, resource_trait_gpu,\n        array_type(arch)(inds), grid_params, pred_params\n    )\n    KernelAbstractions.synchronize(device(arch))\n    return nothing\nend\n\nfunction resolve_consumption!(model::MarineModel, sp::Int, to_eat::Vector{Int})\n    pred_data = model.individuals.animals[sp].data\n    best_prey_idx_cpu = Array(pred_data.best_prey_idx[to_eat]); best_prey_sp_cpu = Array(pred_data.best_prey_sp[to_eat]);\n    best_prey_type_cpu = Array(pred_data.best_prey_type[to_eat]); pred_biomass_cpu = Array(pred_data.biomass_school[to_eat]);\n    pred_gut_full_cpu = Array(pred_data.gut_fullness[to_eat]);\n    prey_biomass_all_cpu = [Array(animal.data.biomass_school) for animal in model.individuals.animals]\n    res_biomass_cpu = Array(model.resources.biomass)\n    successful_rations_cpu = zeros(Float64, length(pred_data.x))\n    prey_claimed = Dict{Tuple{Int, Int}, Float64}()\n    for i in 1:length(to_eat)\n        pred_idx = to_eat[i]; prey_idx = best_prey_idx_cpu[i]\n        if prey_idx == 0; continue; end\n        prey_sp = best_prey_sp_cpu[i]; prey_type = best_prey_type_cpu[i]\n        prey_key = (prey_type, prey_idx)\n        claimed_biomass = get(prey_claimed, prey_key, 0.0)\n        total_biomass = (prey_type == 1) ? prey_biomass_all_cpu[prey_sp][prey_idx] : res_biomass_cpu[prey_idx]\n        available_biomass = total_biomass - claimed_biomass\n        if available_biomass &lt;= 0; continue; end\n        max_stomach = 0.2 * pred_biomass_cpu[i]\n        current_stomach = pred_gut_full_cpu[i] * pred_biomass_cpu[i]\n        stomach_space = max(0.0, max_stomach - current_stomach)\n        ration = min(available_biomass, stomach_space)\n        if ration &gt; 0\n            successful_rations_cpu[pred_idx] = ration\n            prey_claimed[prey_key] = get(prey_claimed, prey_key, 0.0) + ration\n        end\n    end\n    copyto!(@view(pred_data.successful_ration[1:end]), successful_rations_cpu)\nend\n\n@kernel function apply_consumption_kernel!(\n    alive, best_prey_dist, best_prey_idx, best_prey_sp, best_prey_type,\n    x, y, z, pool_x, pool_y, pool_z, length_arr, biomass_school, gut_fullness,\n    ration, active, successful_ration,\n    prey_data_all, resource_biomass_grid,\n    pred_chars, time, grid_params, sp\n)\n    pred_idx = @index(Global)\n    @inbounds if alive[pred_idx] == 1.0\n        s_ration = successful_ration[pred_idx]\n        if s_ration &gt; 0.0\n            dist = sqrt(best_prey_dist[pred_idx])\n            time_left = time[pred_idx]\n            swim_velo = pred_chars.Swim_velo[sp] * (length_arr[pred_idx] / 1000.0)\n            time_to_prey = swim_velo &gt; 0 ? dist / swim_velo : Inf32\n\n            if time_to_prey &lt; time_left\n                time_left -= time_to_prey\n                @atomic active[pred_idx] += time_to_prey / 60.0\n                handling_time = pred_chars.Handling_Time[sp]\n                num_can_handle = handling_time &gt; 0 ? floor(Int, time_left / handling_time) : 0\n                time_spent_handling = num_can_handle * handling_time\n                @atomic ration[pred_idx] += s_ration\n                @atomic gut_fullness[pred_idx] += s_ration / biomass_school[pred_idx]\n                @atomic active[pred_idx] += time_spent_handling / 60.0\n                time[pred_idx] -= (time_to_prey + time_spent_handling)\n            else\n                @atomic active[pred_idx] += time_left / 60.0\n                time[pred_idx] = 0.0\n            end\n            successful_ration[pred_idx] = 0.0\n        end\n    end\nend\n\nfunction apply_consumption!(model::MarineModel, sp::Int, time::AbstractArray, outputs::MarineOutputs)\n    arch = model.arch\n    pred_data = model.individuals.animals[sp].data\n    pred_chars_gpu = (; (k =&gt; array_type(arch)(v.second) for (k, v) in pairs(model.individuals.animals[sp].p))...)\n    prey_data_all = Tuple(animal.data for animal in model.individuals.animals)\n    grid = model.depths.grid\n    grid_params = (\n        lonres = Int(grid[grid.Name .== \"lonres\", :Value][1]), latres = Int(grid[grid.Name .== \"latres\", :Value][1]),\n        depthres = Int(grid[grid.Name .== \"depthres\", :Value][1]), lon_min = grid[grid.Name .== \"xllcorner\", :Value][1],\n        lat_min = grid[grid.Name .== \"yllcorner\", :Value][1], cell_size_deg = grid[grid.Name .== \"cellsize\", :Value][1],\n        depth_res_m = grid[grid.Name .== \"depthmax\", :Value][1] / Int(grid[grid.Name .== \"depthres\", :Value][1])\n    )\n    kernel! = apply_consumption_kernel!(device(arch), 256, (length(pred_data.x),))\n    kernel!(\n        pred_data.alive, pred_data.best_prey_dist, pred_data.best_prey_idx, \n        pred_data.best_prey_sp, pred_data.best_prey_type,\n        pred_data.x, pred_data.y, pred_data.z, pred_data.pool_x, pred_data.pool_y, pred_data.pool_z,\n        pred_data.length, pred_data.biomass_school, pred_data.gut_fullness,\n        pred_data.ration, pred_data.active, pred_data.successful_ration,\n        prey_data_all, model.resources.biomass,\n        pred_chars_gpu, time, grid_params, sp\n    )\n    KernelAbstractions.synchronize(device(arch))\nend\n\n\n\n\nThis system models the mortality imposed on focal species by diffuse, un-modeled predators (e.g., zooplankton). It is a three-kernel process designed for the GPU.\n\n\nThis is the main launcher function. It first calls calculate_prey_biomass_kernel! to sum the biomass of all focal species agents into a 3D grid. It then calls calculate_mortality_rate_kernel!, which uses this prey grid and the resource predator grid (model.resources.biomass) to calculate a mortality rate in each cell based on a Holling Type II functional response. Finally, it launches a kernel for each prey species (apply_resource_mortality_kernel!) to apply this calculated mortality rate to the individual agents.\n# ===================================================================\n# Background Resource Predation System\n# ===================================================================\n\n@inline function resource_predation_mortality_device(\n    prey_biomass::Float64, pred_biomass::Float64, pred_weight::Float64,\n    daily_ration::Float64, handling_time::Float64, dt::Float64\n)\n    (prey_biomass &lt;= 0.0 || pred_biomass &lt;= 0.0) && return 0.0\n    N = prey_biomass / 1000.0\n    total_intake = (pred_biomass / 1000.0) * (daily_ration / 100.0)\n    total_intake &lt;= 0.0 && return 0.0\n    denominator = N - total_intake * handling_time * N\n    FR_day = (denominator &lt;= 1e-9) ? total_intake : (total_intake / denominator * N) / (1.0 + (total_intake / denominator) * handling_time * N)\n    FR_timestep = FR_day * (dt / 1440.0)\n    mortality = (FR_timestep * 1000.0) / prey_biomass\n    return clamp(mortality, 0.0, 1.0)\nend\n\n@kernel function calculate_prey_biomass_kernel!(prey_biomass_grid, animals_all)\n    i = @index(Global)\n    for sp in 1:length(animals_all)\n        animal = animals_all[sp]\n        if i &lt;= length(animal.x) && animal.alive[i] == 1.0\n            @atomic prey_biomass_grid[animal.pool_x[i], animal.pool_y[i], animal.pool_z[i], sp] += animal.biomass_school[i]\n        end\n    end\nend\n\n@kernel function calculate_mortality_rate_kernel!(mortality_rate_grid, pred_biomass_grid, prey_biomass_grid, resource_trait, dt, cell_area)\n    x, y, z, r = @index(Global, NTuple)\n    pred_biom = pred_biomass_grid[x, y, z, r] / cell_area\n    if pred_biom &gt; 0.0\n        min_prey_ratio = resource_trait.Min_Prey[r]\n        max_prey_ratio = resource_trait.Max_Prey[r]\n        max_ingestion = resource_trait.Daily_Ration[r]\n        handling_time = Float64(resource_trait.Handling_Time[r])\n        max_pred_size = resource_trait.Max_Size[r]\n        μ_pred, σ_pred = lognormal_params_from_maxsize(Int(max_pred_size))\n        pred_length_mean = exp(μ_pred + 0.5 * σ_pred^2)\n        pred_weight_mean = resource_trait.LWR_a[r] * (pred_length_mean / 10)^resource_trait.LWR_b[r]\n        \n        total_available_biomass = 0.0\n        for sp in 1:size(prey_biomass_grid, 4)\n            total_available_biomass += prey_biomass_grid[x, y, z, sp]\n        end\n\n        if total_available_biomass &gt; 0.0\n            for sp in 1:size(prey_biomass_grid, 4)\n                prey_biom = prey_biomass_grid[x, y, z, sp] / cell_area\n                if prey_biom &gt; 0\n                    prop_ingestion = (prey_biom / (total_available_biomass / cell_area)) * max_ingestion\n                    mortality_rate = resource_predation_mortality_device(prey_biom, pred_biom, pred_weight_mean, prop_ingestion, handling_time, dt)\n                    mortality_rate_grid[x, y, z, r, sp] = mortality_rate\n                end\n            end\n        end\n    end\nend\n\n@kernel function apply_resource_mortality_kernel!(animal_data, mortality_rate_grid, sp_idx)\n    i = @index(Global)\n    if i &lt;= length(animal_data.x) && animal_data.alive[i] == 1.0\n        x, y, z = animal_data.pool_x[i], animal_data.pool_y[i], animal_data.pool_z[i]\n        total_mortality_rate = 0.0\n        for r in 1:size(mortality_rate_grid, 4)\n            total_mortality_rate += mortality_rate_grid[x, y, z, r, sp_idx]\n        end\n        if total_mortality_rate &gt; 0\n            total_mortality_rate = min(total_mortality_rate, 1.0)\n            biomass_removed = animal_data.biomass_school[i] * total_mortality_rate\n            @atomic animal_data.biomass_school[i] -= biomass_removed\n            if animal_data.biomass_ind[i] &gt; 0\n                inds_removed = floor(Int, biomass_removed / animal_data.biomass_ind[i])\n                @atomic animal_data.abundance[i] -= Float64(inds_removed)\n            end\n            if animal_data.abundance[i] &lt;= 0; animal_data.alive[i] = 0.0; end\n        end\n    end\nend\n\nfunction resource_predation!(model::MarineModel, output::MarineOutputs)\n    arch = model.arch\n    g = model.depths.grid\n    lonres = Int(g[g.Name .== \"lonres\", :Value][1])\n    latres = Int(g[g.Name .== \"latres\", :Value][1])\n    depthres = Int(g[g.Name .== \"depthres\", :Value][1])\n    n_sp = model.n_species\n    n_res = model.n_resource\n    \n    trait_df = model.resource_trait\n    resource_trait_gpu = (; (Symbol(c) =&gt; array_type(arch)(trait_df[:, c]) for c in names(trait_df))...)\n\n    prey_biomass_grid = array_type(arch)(zeros(Float64, lonres, latres, depthres, n_sp))\n    mortality_rate_grid = array_type(arch)(zeros(Float32, lonres, latres, depthres, n_res, n_sp))\n    \n    animals_all = Tuple(animal.data for animal in model.individuals.animals)\n    cell_area = 1.0 # Placeholder\n\n    max_len = 0\n    if !isempty(animals_all)\n        max_len = maximum(length(a.x) for a in animals_all if !isempty(a.x))\n    end\n    \n    if max_len &gt; 0\n        kernel1 = calculate_prey_biomass_kernel!(device(arch), 256, (max_len,))\n        kernel1(prey_biomass_grid, animals_all)\n    end\n    \n    kernel2_ndrange = (lonres, latres, depthres, n_res)\n    kernel2 = calculate_mortality_rate_kernel!(device(arch), (8,8,4,1), kernel2_ndrange)\n    kernel2(mortality_rate_grid, model.resources.biomass, prey_biomass_grid, resource_trait_gpu, model.dt, cell_area)\n\n    for sp_idx in 1:n_sp\n        agents = model.individuals.animals[sp_idx].data\n        if length(agents.x) &gt; 0\n            kernel3 = apply_resource_mortality_kernel!(device(arch), 256, (length(agents.x),))\n            kernel3(agents, mortality_rate_grid, sp_idx)\n        end\n    end\n    \n    KernelAbstractions.synchronize(device(arch))\n    return nothing\nend",
    "crumbs": [
      "Model Components",
      "Predation Components"
    ]
  },
  {
    "objectID": "components/movement.html",
    "href": "components/movement.html",
    "title": "SwimmingIndividuals.jl",
    "section": "",
    "text": "The movement.jl file contains all the functions that govern how agents move through the model world. This includes both the default habitat-seeking behavior and the specialized, archetype-specific movements like Diel Vertical Migration (DVM) and the foraging dives of pelagic animals.\n\n\nThese are CPU-based helper functions that provide the core logic for the general habitat-seeking behavior. They handle tasks like finding a valid path through the grid and calculating how far an agent can travel along that path in a single timestep.\n\n\nThis function implements a Breadth-First Search (BFS) algorithm to find the shortest path between two grid cells (start and goal). Crucially, the path is constrained to only travel through cells that have a habitat capacity greater than zero, preventing agents from moving across land or other unsuitable areas.\n\n\n\nOnce a path has been found, this function determines the exact geographic coordinates an agent can reach along that path within a single timestep. It calculates the total distance of the path and compares it to the maximum distance the agent can travel (based on its swim speed). If the path is longer than the agent can travel, it interpolates to find the precise point along the path where the agent’s movement ends.\n\n\n\nThis function is a failsafe for agents that find themselves in a grid cell with zero habitat capacity. It performs a search outward from the agent’s current location to find the closest valid habitat cell and calculates a new position within that cell.\n\n\n\nA simple helper function to calculate an agent’s swim speed in body lengths per second, based on its size and a species-specific speed parameter.\n# ===================================================================\n# Pathfinding and Movement Helpers (CPU-based)\n# ===================================================================\n\nfunction find_path(capacity::Matrix{Float64}, start::Tuple{Int,Int}, goal::Tuple{Int,Int})\n    open_set = [start]\n    came_from = Dict{Tuple{Int,Int}, Tuple{Int,Int}}()\n    visited = Set{Tuple{Int,Int}}()\n    directions = [(1,0), (-1,0), (0,1), (0,-1), (1,1), (-1,-1), (1,-1), (-1,1)]\n    lonres, latres = size(capacity)\n    \n    while !isempty(open_set)\n        current = popfirst!(open_set)\n        if current == goal\n            path = [current]\n            while current in keys(came_from)\n                current = came_from[current]\n                pushfirst!(path, current)\n            end\n            return path\n        end\n        push!(visited, current)\n        for (dx, dy) in directions\n            nx, ny = current[1] + dx, current[2] + dy\n            if 1 &lt;= nx &lt;= lonres && 1 &lt;= ny &lt;= latres\n                neighbor = (nx, ny)\n                if capacity[nx, ny] &gt; 0 && !(neighbor in visited) && !(neighbor in open_set)\n                    push!(open_set, neighbor)\n                    came_from[neighbor] = current\n                end\n            end\n        end\n    end\n    return nothing\nend\n\nfunction reachable_point(current_pos::Tuple{Float64, Float64}, path::Vector{Tuple{Int, Int}}, max_distance::Float64, latmax::Float64, lonmin::Float64, cell_size::Float64, lonres::Int, latres::Int)\n    function grid_to_coords(cell::Tuple{Int, Int})\n        lon_idx, lat_idx = cell\n        lon = lonmin + (lon_idx - 1 + rand()) * cell_size\n        lat = latmax - (lat_idx - 1 + rand()) * cell_size \n        return (lat, lon)\n    end\n\n    total_distance = 0.0\n    prev_lat, prev_lon = current_pos\n\n    for i in 1:length(path)\n        lat, lon = grid_to_coords(path[i])\n        d = haversine(prev_lat, prev_lon, lat, lon)\n        total_distance += d\n\n        if total_distance &gt; max_distance\n            excess = total_distance - max_distance\n            frac = 1 - (excess / d)\n            interp_lat = prev_lat + frac * (lat - prev_lat)\n            interp_lon = prev_lon + frac * (lon - prev_lon)\n            \n            grid_x = clamp(Int(floor((interp_lon - lonmin) / cell_size) + 1), 1, lonres)\n            grid_y = clamp(Int(floor((latmax - interp_lat) / cell_size) + 1), 1, latres)\n            \n            return (interp_lat, interp_lon, grid_y, grid_x)\n        end\n        prev_lat, prev_lon = lat, lon\n    end\n\n    final_cell = path[end]\n    final_lat, final_lon = grid_to_coords(final_cell)\n    return (final_lat, final_lon, final_cell[2], final_cell[1])\nend\n\nfunction nearest_suitable_habitat(habitat::Matrix{Float64}, start_latlon::Tuple{Float64, Float64}, start_pool::Tuple{Int,Int}, max_distance_m::Float64, latmax::Float64, lonmin::Float64, cellsize_deg::Float64)\n    R = 6371000.0\n    lonres, latres = size(habitat)\n    \n    get_neighbors(x, y) = [(x+dx, y+dy) for (dx, dy) in ((-1,0),(1,0),(0,-1),(0,1),(-1,-1),(-1,1),(1,-1),(1,1)) if 1&lt;=x+dx&lt;=lonres && 1&lt;=y+dy&lt;=latres]\n    random_point_in_cell(cell) = (latmax - (cell[2]-1+rand())*cellsize_deg, lonmin+(cell[1]-1+rand())*cellsize_deg)\n\n    visited = falses(lonres, latres)\n    queue = [start_pool]\n    visited[start_pool...] = true\n    \n    goal_cell = nothing\n    while !isempty(queue)\n        current = popfirst!(queue)\n        if habitat[current...] &gt; 0\n            goal_cell = current\n            break\n        end\n        for neighbor in get_neighbors(current[1], current[2])\n            if !visited[neighbor...]\n                visited[neighbor...] = true\n                push!(queue, neighbor)\n            end\n        end\n    end\n\n    isnothing(goal_cell) && return nothing\n\n    goal_latlon = random_point_in_cell(goal_cell)\n    dist_m = haversine(start_latlon[1], start_latlon[2], goal_latlon[1], goal_latlon[2])\n\n    if dist_m &lt;= max_distance_m\n        new_latlon = goal_latlon\n    else\n        φ1, λ1 = deg2rad(start_latlon[1]), deg2rad(start_latlon[2])\n        φ2, λ2 = deg2rad(goal_latlon[1]), deg2rad(goal_latlon[2])\n        Δλ = λ2 - λ1\n        θ = atan(sin(Δλ) * cos(φ2), cos(φ1) * sin(φ2) - sin(φ1) * cos(φ2) * cos(Δλ))\n        δ = max_distance_m / R\n        new_φ = asin(sin(φ1) * cos(δ) + cos(φ1) * sin(δ) * cos(θ))\n        new_λ = λ1 + atan(sin(θ) * sin(δ) * cos(φ1), cos(δ) - sin(φ1) * sin(new_φ))\n        new_latlon = (rad2deg(new_φ), rad2deg(new_λ))\n    end\n\n    new_lon_idx = clamp(floor(Int, (new_latlon[2] - lonmin) / cellsize_deg) + 1, 1, lonres)\n    new_lat_idx = clamp(floor(Int, (latmax - new_latlon[1]) / cellsize_deg) + 1, 1, latres)\n    \n    return new_latlon[1], new_latlon[2], new_lon_idx, new_lat_idx\nend\n\nfunction bl_per_s(length, speed; b=0.35, min_speed = 0.5)\n    return max.(speed .* length .^ (-b), min_speed)\nend\n\n\n\n\nThese are high-performance GPU kernels that manage the state-machine logic for specialized behavioral archetypes.\n\n\nThis system manages Diel Vertical Migration. The launcher function (dvm_action!) first determines if it is day or night and pre-calculates a random target depth for each agent based on the species’ day/night vertical distribution profiles. It then calls the dvm_action_kernel!, which runs in parallel for all agents, moving them towards their assigned target depth and updating their migration status.\n\n\n\nThis system manages the behavior of air-breathing divers. The dive_action_kernel! implements a state machine for each agent, cycling through states like “at surface,” “descending,” “foraging at depth,” and “ascending.” The decision to dive is probabilistic and is based on the agent’s gut fullness and the time it has spent at the surface.\n# ===================================================================\n# Specialized Movement Kernels (DVM and Diving)\n# ===================================================================\n\n@kernel function dvm_action_kernel!(\n    alive, mig_status, z, target_z, pool_z, active,\n    p_gpu, maxdepth, depth_res_m, depthres, t, dt, sp\n)\n    ind = @index(Global)\n    @inbounds if alive[ind] == 1.0\n        my_status = mig_status[ind]\n        my_z = z[ind]\n        swim_speed = 2.68f0\n        z_increment = swim_speed * Float32(dt)\n        is_daytime = (360.0f0 &lt;= t &lt; 1080.0f0)\n        \n        if is_daytime\n            if my_status == 0.0f0\n                mig_status[ind] = 2.0f0\n                z[ind] = min(target_z[ind], my_z + z_increment)\n            elseif my_status == 2.0f0\n                z[ind] = min(target_z[ind], my_z + z_increment)\n                if z[ind] &gt;= target_z[ind]; mig_status[ind] = -1.0f0; end\n            end\n        else\n            if my_status == -1.0f0\n                mig_status[ind] = 1.0f0\n                z[ind] = max(target_z[ind], my_z - z_increment)\n            elseif my_status == 1.0f0\n                z[ind] = max(target_z[ind], my_z - z_increment)\n                if z[ind] &lt;= target_z[ind]; mig_status[ind] = 0.0f0; end\n            end\n        end\n        \n        @inbounds pool_z[ind] = clamp(ceil(Int, z[ind] / depth_res_m), 1, depthres)\n        @inbounds active[ind] += dt\n    end\nend\n\nfunction dvm_action!(model::MarineModel, sp::Int)\n    arch = model.arch\n    data = model.individuals.animals[sp].data\n    p_cpu = model.individuals.animals[sp].p\n    \n    p_gpu = (; (k =&gt; array_type(arch)(v.second) for (k, v) in pairs(p_cpu))...)\n    \n    grid = model.depths.grid\n    maxdepth = grid[grid.Name .== \"depthmax\", :Value][1]\n    depthres = Int(grid[grid.Name .== \"depthres\", :Value][1])\n    depth_res_m = maxdepth / depthres\n    \n    is_daytime = (360.0 &lt;= model.t &lt; 1080.0)\n    dist_params = is_daytime ? model.depths.focal_day[sp, :] : model.depths.focal_night[sp, :]\n    \n    target_z_cpu = gaussmix(length(data.x), dist_params.mu1, dist_params.mu2, dist_params.mu3,\n                                           dist_params.sigma1, dist_params.sigma2, dist_params.sigma3,\n                                           dist_params.lambda1, dist_params.lambda2)\n    copyto!(data.target_z, Float32.(target_z_cpu))\n\n    kernel! = dvm_action_kernel!(device(arch), 256, (length(data.x),))\n    kernel!(\n        data.alive, data.mig_status, data.z, data.target_z, data.pool_z, data.active,\n        p_gpu, maxdepth, depth_res_m, depthres, model.t, model.dt, sp\n    )\n    KernelAbstractions.synchronize(device(arch))\nend\n\n@kernel function dive_action_kernel!(\n    alive, mig_status, interval, z, dives_remaining, gut_fullness,\n    biomass_school, length_arr, target_z, pool_z, active,\n    surface_interval, dive_interval, swim_velo, dive_max, dive_min,\n    depth_res_m, depthres, t, dt\n)\n    ind = @index(Global)\n    @inbounds if alive[ind] == 1.0\n        my_status = mig_status[ind]\n        my_interval = interval[ind]\n        my_z = z[ind]\n        my_dives_remaining = dives_remaining[ind]\n        my_fullness = gut_fullness[ind]\n        my_biomass = biomass_school[ind]\n        \n        dive_velo_ms = swim_velo * (length_arr[ind] / 1000.0f0) * 60.0f0\n        z_increment = dive_velo_ms * Float32(dt)\n\n        if my_status == 0.0f0 && my_dives_remaining &gt; 0\n            my_interval += dt\n            max_fullness = 0.2f0 * my_biomass\n            fullness_ratio = max_fullness &gt; 0 ? my_fullness / max_fullness : 1.0f0\n            dive_prob = 1.0f0 - (1.0f0 / (1.0f0 + exp(-5.0f0 * (fullness_ratio - 0.5f0))))\n            if my_interval &gt;= surface_interval && rand(Float32) &lt; dive_prob\n                mig_status[ind] = 1.0f0\n                interval[ind] = 0.0f0\n                target_z[ind] = rand(Float32) * (dive_max - dive_min) + dive_min\n            else\n                interval[ind] = my_interval\n            end\n        elseif my_status == 1.0f0\n            z[ind] = min(target_z[ind], my_z + z_increment)\n            if z[ind] &gt;= target_z[ind]; mig_status[ind] = -1.0f0; end\n        elseif my_status == -1.0f0\n            my_interval += dt\n            if my_interval &gt;= dive_interval\n                mig_status[ind] = 2.0f0\n                interval[ind] = 0.0f0\n            else\n                interval[ind] = my_interval\n            end\n        elseif my_status == 2.0f0\n            z[ind] = max(1.0f0, my_z - z_increment)\n            if z[ind] &lt;= 1.0f0\n                mig_status[ind] = 0.0f0\n                dives_remaining[ind] -= 1\n            end\n        end\n        \n        @inbounds pool_z[ind] = clamp(ceil(Int, z[ind] / depth_res_m), 1, depthres)\n        @inbounds active[ind] += dt\n    end\nend\n\nfunction dive_action!(model::MarineModel, sp::Int)\n    arch = model.arch\n    data = model.individuals.animals[sp].data\n    p_cpu = model.individuals.animals[sp].p\n    \n    surface_interval = p_cpu.Surface_Interval.second[sp]\n    dive_interval = p_cpu.Dive_Interval.second[sp]\n    swim_velo = p_cpu.Swim_velo.second[sp]\n    dive_max = p_cpu.Dive_Max.second[sp]\n    dive_min = p_cpu.Dive_Min.second[sp]\n    \n    grid = model.depths.grid\n    depthres = Int(grid[grid.Name .== \"depthres\", :Value][1])\n    depth_res_m = grid[grid.Name .== \"depthmax\", :Value][1] / depthres\n\n    kernel! = dive_action_kernel!(device(arch), 256, (length(data.x),))\n    kernel!(\n        data.alive, data.mig_status, data.interval, data.z, data.dives_remaining,\n        data.gut_fullness, data.biomass_school, data.length, data.target_z,\n        data.pool_z, data.active,\n        surface_interval, dive_interval, swim_velo, dive_max, dive_min,\n        depth_res_m, depthres, model.t, model.dt\n    )\n    KernelAbstractions.synchronize(device(arch))\nend\n\n\n\n\nThis is the default movement behavior for agents that are not engaged in a specialized activity. It uses the “Gather, Compute, Update” pattern to remain architecture-compliant.\n\n\nThis function orchestrates the habitat-seeking process. It first gathers all necessary agent and environmental data from the GPU to the CPU. It then uses multi-threading to loop over each agent. For each agent, it determines a target location based on habitat quality and calculates a new position using the pathfinding helper functions. Finally, it copies the updated positions and active time back to the GPU.\n# ===================================================================\n# General Habitat-Seeking Movement\n# ===================================================================\n\nfunction movement_toward_habitat!(model::MarineModel, sp::Int, time::AbstractArray)\n    # --- 1. GATHER DATA FROM DEVICE TO CPU ---\n    arch = model.arch\n    animal_data = model.individuals.animals[sp].data\n    animal_param = model.individuals.animals[sp].p\n    \n    cpu_time = Array(time)\n    cpu_x, cpu_y = Array(animal_data.x), Array(animal_data.y)\n    cpu_pool_x, cpu_pool_y = Array(animal_data.pool_x), Array(animal_data.pool_y)\n    cpu_length = Array(animal_data.length)\n    cpu_alive = Array(animal_data.alive)\n    cpu_active = Array(animal_data.active)\n\n    new_x, new_y = copy(cpu_x), copy(cpu_y)\n    new_pool_x, new_pool_y = copy(cpu_pool_x), copy(cpu_pool_y)\n    \n    month = model.environment.ts\n    # The habitat array is (lon, lat)\n    habitat = Array(model.capacities[:, :, month, sp])\n    grid = model.depths.grid\n    latmax = grid[grid.Name .== \"yulcorner\", :Value][1]\n    lonmin = grid[grid.Name .== \"xllcorner\", :Value][1]\n    cell_size = grid[grid.Name .== \"cellsize\", :Value][1]\n    lonres, latres = size(habitat)\n\n    # Precompute list of all valid habitat cells across the entire grid\n    habitat_cells = [(x=i, y=j, value=habitat[i,j]) for i in 1:lonres, j in 1:latres if habitat[i,j] &gt; 0]\n    \n    if !isempty(habitat_cells)\n        sort!(habitat_cells, by = x -&gt; x.value, rev = true)\n        cumvals = cumsum(getfield.(habitat_cells, :value))\n        total_val = cumvals[end]\n\n        # --- 2. PERFORM MOVEMENT LOGIC ON CPU ---\n        Threads.@threads for ind in 1:length(cpu_x)\n            if cpu_alive[ind] == 1.0 && cpu_time[ind] &gt; 0\n                \n                cpu_active[ind] += cpu_time[ind] / 60.0\n\n                start_x, start_y = cpu_pool_x[ind], cpu_pool_y[ind]\n                cur_x, cur_y = cpu_x[ind], cpu_y[ind]\n                len_m = cpu_length[ind] / 1000.0\n                swim_speed_ms = bl_per_s(len_m*100, animal_param.Swim_velo[2][sp]) * len_m\n                max_dist = swim_speed_ms * cpu_time[ind]\n\n                # If agent is in unsuitable habitat, find the NEAREST valid cell\n                if habitat[start_x, start_y] == 0\n                    res = nearest_suitable_habitat(habitat, (cur_y, cur_x), (start_x, start_y), max_dist, latmax, lonmin, cell_size)\n                    if res !== nothing\n                        # Note: nearest_suitable_habitat returns (lat, lon, lon_idx, lat_idx)\n                        new_y[ind], new_x[ind], new_pool_x[ind], new_pool_y[ind] = res\n                    end\n                else\n                    # Agent is in suitable habitat, so it will pick a better spot globally\n                    r = (rand()^4) * total_val\n                    idx = findfirst(x -&gt; x &gt;= r, cumvals)\n                    if idx !== nothing\n                        target_x, target_y = habitat_cells[idx].x, habitat_cells[idx].y\n                        \n                        path = find_path(habitat, (start_x, start_y), (target_x, target_y))\n                        \n                        if path !== nothing && !isempty(path)\n                            # reachable_point returns (lat, lon, lat_idx, lon_idx)\n                            res_lat, res_lon, res_pool_y, res_pool_x = reachable_point((cur_y, cur_x), path, max_dist, latmax, lonmin, cell_size, lonres, latres)\n                            \n                            # Assign to the correct variables\n                            new_y[ind] = res_lat\n                            new_x[ind] = res_lon\n                            new_pool_y[ind] = res_pool_y\n                            new_pool_x[ind] = res_pool_x\n                        end\n                    end\n                end\n            end\n        end\n    end\n\n    # --- 3. UPDATE DEVICE ARRAYS WITH RESULTS ---\n    copyto!(animal_data.x, new_x)\n    copyto!(animal_data.y, new_y)\n    copyto!(animal_data.pool_x, new_pool_x)\n    copyto!(animal_data.pool_y, new_pool_y)\n    copyto!(animal_data.active, cpu_active)\n\n    return nothing\nend\n\n\n\n\nThis system is responsible for the monthly “shuffling” of the resource grids.\n\n\nThis high-level function is called from the main TimeStep! loop whenever a new month begins. It first calculates the total biomass for each resource species currently in the model. It then calls the move_resources_kernel! to redistribute this total biomass across the grid according to the habitat capacity map for the new month. This process ensures that resource availability tracks the seasonal changes in the environment.\n# ===================================================================\n# Monthly Resource Redistribution System\n# ===================================================================\n\n@kernel function move_resources_kernel!(\n    new_biomass_grid, capacities_for_month, \n    total_biomass_per_sp, total_capacity_per_sp\n)\n    lon, lat, depth = @index(Global, NTuple)\n    for sp in 1:size(new_biomass_grid, 4)\n        total_biomass = total_biomass_per_sp[sp]\n        total_capacity = total_capacity_per_sp[sp]\n        if total_biomass &gt; 0 && total_capacity &gt; 0\n            capacity_this_cell = capacities_for_month[lon, lat, sp]\n            if depth &lt;= 5\n                new_biomass = (capacity_this_cell / total_capacity) * total_biomass / 5.0\n                @inbounds new_biomass_grid[lon, lat, depth, sp] = new_biomass\n            else\n                @inbounds new_biomass_grid[lon, lat, depth, sp] = 0.0\n            end\n        else\n            @inbounds new_biomass_grid[lon, lat, depth, sp] = 0.0\n        end\n    end\nend\n\nfunction move_resources!(model::MarineModel, month::Int)\n    arch = model.arch\n    g = model.depths.grid\n    lonres = Int(g[g.Name .== \"lonres\", :Value][1])\n    latres = Int(g[g.Name .== \"latres\", :Value][1])\n    depthres = Int(g[g.Name .== \"depthres\", :Value][1])\n    n_res = model.n_resource\n    n_sp = model.n_species\n\n    total_biomass_per_sp = reshape(sum(model.resources.biomass, dims=(1,2,3)), n_res)\n    capacities_for_month = array_type(arch)(@view model.capacities[:, :, month, (n_sp+1):(n_sp+n_res)])\n    total_capacity_per_sp = reshape(sum(capacities_for_month, dims=(1,2)), n_res)\n    new_biomass_grid = array_type(arch)(zeros(Float64, lonres, latres, depthres, n_res))\n\n    kernel! = move_resources_kernel!(device(arch), (8,8,4), (lonres, latres, depthres))\n    kernel!(new_biomass_grid, capacities_for_month, total_biomass_per_sp, total_capacity_per_sp)\n    KernelAbstractions.synchronize(device(arch))\n\n    model.resources.biomass .= new_biomass_grid\n    model.resources.capacity .= new_biomass_grid\n    return nothing\nend",
    "crumbs": [
      "Model Components",
      "Movement Processes"
    ]
  },
  {
    "objectID": "components/movement.html#movement-processes",
    "href": "components/movement.html#movement-processes",
    "title": "SwimmingIndividuals.jl",
    "section": "",
    "text": "The movement.jl file contains all the functions that govern how agents move through the model world. This includes both the default habitat-seeking behavior and the specialized, archetype-specific movements like Diel Vertical Migration (DVM) and the foraging dives of pelagic animals.\n\n\nThese are CPU-based helper functions that provide the core logic for the general habitat-seeking behavior. They handle tasks like finding a valid path through the grid and calculating how far an agent can travel along that path in a single timestep.\n\n\nThis function implements a Breadth-First Search (BFS) algorithm to find the shortest path between two grid cells (start and goal). Crucially, the path is constrained to only travel through cells that have a habitat capacity greater than zero, preventing agents from moving across land or other unsuitable areas.\n\n\n\nOnce a path has been found, this function determines the exact geographic coordinates an agent can reach along that path within a single timestep. It calculates the total distance of the path and compares it to the maximum distance the agent can travel (based on its swim speed). If the path is longer than the agent can travel, it interpolates to find the precise point along the path where the agent’s movement ends.\n\n\n\nThis function is a failsafe for agents that find themselves in a grid cell with zero habitat capacity. It performs a search outward from the agent’s current location to find the closest valid habitat cell and calculates a new position within that cell.\n\n\n\nA simple helper function to calculate an agent’s swim speed in body lengths per second, based on its size and a species-specific speed parameter.\n# ===================================================================\n# Pathfinding and Movement Helpers (CPU-based)\n# ===================================================================\n\nfunction find_path(capacity::Matrix{Float64}, start::Tuple{Int,Int}, goal::Tuple{Int,Int})\n    open_set = [start]\n    came_from = Dict{Tuple{Int,Int}, Tuple{Int,Int}}()\n    visited = Set{Tuple{Int,Int}}()\n    directions = [(1,0), (-1,0), (0,1), (0,-1), (1,1), (-1,-1), (1,-1), (-1,1)]\n    lonres, latres = size(capacity)\n    \n    while !isempty(open_set)\n        current = popfirst!(open_set)\n        if current == goal\n            path = [current]\n            while current in keys(came_from)\n                current = came_from[current]\n                pushfirst!(path, current)\n            end\n            return path\n        end\n        push!(visited, current)\n        for (dx, dy) in directions\n            nx, ny = current[1] + dx, current[2] + dy\n            if 1 &lt;= nx &lt;= lonres && 1 &lt;= ny &lt;= latres\n                neighbor = (nx, ny)\n                if capacity[nx, ny] &gt; 0 && !(neighbor in visited) && !(neighbor in open_set)\n                    push!(open_set, neighbor)\n                    came_from[neighbor] = current\n                end\n            end\n        end\n    end\n    return nothing\nend\n\nfunction reachable_point(current_pos::Tuple{Float64, Float64}, path::Vector{Tuple{Int, Int}}, max_distance::Float64, latmax::Float64, lonmin::Float64, cell_size::Float64, lonres::Int, latres::Int)\n    function grid_to_coords(cell::Tuple{Int, Int})\n        lon_idx, lat_idx = cell\n        lon = lonmin + (lon_idx - 1 + rand()) * cell_size\n        lat = latmax - (lat_idx - 1 + rand()) * cell_size \n        return (lat, lon)\n    end\n\n    total_distance = 0.0\n    prev_lat, prev_lon = current_pos\n\n    for i in 1:length(path)\n        lat, lon = grid_to_coords(path[i])\n        d = haversine(prev_lat, prev_lon, lat, lon)\n        total_distance += d\n\n        if total_distance &gt; max_distance\n            excess = total_distance - max_distance\n            frac = 1 - (excess / d)\n            interp_lat = prev_lat + frac * (lat - prev_lat)\n            interp_lon = prev_lon + frac * (lon - prev_lon)\n            \n            grid_x = clamp(Int(floor((interp_lon - lonmin) / cell_size) + 1), 1, lonres)\n            grid_y = clamp(Int(floor((latmax - interp_lat) / cell_size) + 1), 1, latres)\n            \n            return (interp_lat, interp_lon, grid_y, grid_x)\n        end\n        prev_lat, prev_lon = lat, lon\n    end\n\n    final_cell = path[end]\n    final_lat, final_lon = grid_to_coords(final_cell)\n    return (final_lat, final_lon, final_cell[2], final_cell[1])\nend\n\nfunction nearest_suitable_habitat(habitat::Matrix{Float64}, start_latlon::Tuple{Float64, Float64}, start_pool::Tuple{Int,Int}, max_distance_m::Float64, latmax::Float64, lonmin::Float64, cellsize_deg::Float64)\n    R = 6371000.0\n    lonres, latres = size(habitat)\n    \n    get_neighbors(x, y) = [(x+dx, y+dy) for (dx, dy) in ((-1,0),(1,0),(0,-1),(0,1),(-1,-1),(-1,1),(1,-1),(1,1)) if 1&lt;=x+dx&lt;=lonres && 1&lt;=y+dy&lt;=latres]\n    random_point_in_cell(cell) = (latmax - (cell[2]-1+rand())*cellsize_deg, lonmin+(cell[1]-1+rand())*cellsize_deg)\n\n    visited = falses(lonres, latres)\n    queue = [start_pool]\n    visited[start_pool...] = true\n    \n    goal_cell = nothing\n    while !isempty(queue)\n        current = popfirst!(queue)\n        if habitat[current...] &gt; 0\n            goal_cell = current\n            break\n        end\n        for neighbor in get_neighbors(current[1], current[2])\n            if !visited[neighbor...]\n                visited[neighbor...] = true\n                push!(queue, neighbor)\n            end\n        end\n    end\n\n    isnothing(goal_cell) && return nothing\n\n    goal_latlon = random_point_in_cell(goal_cell)\n    dist_m = haversine(start_latlon[1], start_latlon[2], goal_latlon[1], goal_latlon[2])\n\n    if dist_m &lt;= max_distance_m\n        new_latlon = goal_latlon\n    else\n        φ1, λ1 = deg2rad(start_latlon[1]), deg2rad(start_latlon[2])\n        φ2, λ2 = deg2rad(goal_latlon[1]), deg2rad(goal_latlon[2])\n        Δλ = λ2 - λ1\n        θ = atan(sin(Δλ) * cos(φ2), cos(φ1) * sin(φ2) - sin(φ1) * cos(φ2) * cos(Δλ))\n        δ = max_distance_m / R\n        new_φ = asin(sin(φ1) * cos(δ) + cos(φ1) * sin(δ) * cos(θ))\n        new_λ = λ1 + atan(sin(θ) * sin(δ) * cos(φ1), cos(δ) - sin(φ1) * sin(new_φ))\n        new_latlon = (rad2deg(new_φ), rad2deg(new_λ))\n    end\n\n    new_lon_idx = clamp(floor(Int, (new_latlon[2] - lonmin) / cellsize_deg) + 1, 1, lonres)\n    new_lat_idx = clamp(floor(Int, (latmax - new_latlon[1]) / cellsize_deg) + 1, 1, latres)\n    \n    return new_latlon[1], new_latlon[2], new_lon_idx, new_lat_idx\nend\n\nfunction bl_per_s(length, speed; b=0.35, min_speed = 0.5)\n    return max.(speed .* length .^ (-b), min_speed)\nend\n\n\n\n\nThese are high-performance GPU kernels that manage the state-machine logic for specialized behavioral archetypes.\n\n\nThis system manages Diel Vertical Migration. The launcher function (dvm_action!) first determines if it is day or night and pre-calculates a random target depth for each agent based on the species’ day/night vertical distribution profiles. It then calls the dvm_action_kernel!, which runs in parallel for all agents, moving them towards their assigned target depth and updating their migration status.\n\n\n\nThis system manages the behavior of air-breathing divers. The dive_action_kernel! implements a state machine for each agent, cycling through states like “at surface,” “descending,” “foraging at depth,” and “ascending.” The decision to dive is probabilistic and is based on the agent’s gut fullness and the time it has spent at the surface.\n# ===================================================================\n# Specialized Movement Kernels (DVM and Diving)\n# ===================================================================\n\n@kernel function dvm_action_kernel!(\n    alive, mig_status, z, target_z, pool_z, active,\n    p_gpu, maxdepth, depth_res_m, depthres, t, dt, sp\n)\n    ind = @index(Global)\n    @inbounds if alive[ind] == 1.0\n        my_status = mig_status[ind]\n        my_z = z[ind]\n        swim_speed = 2.68f0\n        z_increment = swim_speed * Float32(dt)\n        is_daytime = (360.0f0 &lt;= t &lt; 1080.0f0)\n        \n        if is_daytime\n            if my_status == 0.0f0\n                mig_status[ind] = 2.0f0\n                z[ind] = min(target_z[ind], my_z + z_increment)\n            elseif my_status == 2.0f0\n                z[ind] = min(target_z[ind], my_z + z_increment)\n                if z[ind] &gt;= target_z[ind]; mig_status[ind] = -1.0f0; end\n            end\n        else\n            if my_status == -1.0f0\n                mig_status[ind] = 1.0f0\n                z[ind] = max(target_z[ind], my_z - z_increment)\n            elseif my_status == 1.0f0\n                z[ind] = max(target_z[ind], my_z - z_increment)\n                if z[ind] &lt;= target_z[ind]; mig_status[ind] = 0.0f0; end\n            end\n        end\n        \n        @inbounds pool_z[ind] = clamp(ceil(Int, z[ind] / depth_res_m), 1, depthres)\n        @inbounds active[ind] += dt\n    end\nend\n\nfunction dvm_action!(model::MarineModel, sp::Int)\n    arch = model.arch\n    data = model.individuals.animals[sp].data\n    p_cpu = model.individuals.animals[sp].p\n    \n    p_gpu = (; (k =&gt; array_type(arch)(v.second) for (k, v) in pairs(p_cpu))...)\n    \n    grid = model.depths.grid\n    maxdepth = grid[grid.Name .== \"depthmax\", :Value][1]\n    depthres = Int(grid[grid.Name .== \"depthres\", :Value][1])\n    depth_res_m = maxdepth / depthres\n    \n    is_daytime = (360.0 &lt;= model.t &lt; 1080.0)\n    dist_params = is_daytime ? model.depths.focal_day[sp, :] : model.depths.focal_night[sp, :]\n    \n    target_z_cpu = gaussmix(length(data.x), dist_params.mu1, dist_params.mu2, dist_params.mu3,\n                                           dist_params.sigma1, dist_params.sigma2, dist_params.sigma3,\n                                           dist_params.lambda1, dist_params.lambda2)\n    copyto!(data.target_z, Float32.(target_z_cpu))\n\n    kernel! = dvm_action_kernel!(device(arch), 256, (length(data.x),))\n    kernel!(\n        data.alive, data.mig_status, data.z, data.target_z, data.pool_z, data.active,\n        p_gpu, maxdepth, depth_res_m, depthres, model.t, model.dt, sp\n    )\n    KernelAbstractions.synchronize(device(arch))\nend\n\n@kernel function dive_action_kernel!(\n    alive, mig_status, interval, z, dives_remaining, gut_fullness,\n    biomass_school, length_arr, target_z, pool_z, active,\n    surface_interval, dive_interval, swim_velo, dive_max, dive_min,\n    depth_res_m, depthres, t, dt\n)\n    ind = @index(Global)\n    @inbounds if alive[ind] == 1.0\n        my_status = mig_status[ind]\n        my_interval = interval[ind]\n        my_z = z[ind]\n        my_dives_remaining = dives_remaining[ind]\n        my_fullness = gut_fullness[ind]\n        my_biomass = biomass_school[ind]\n        \n        dive_velo_ms = swim_velo * (length_arr[ind] / 1000.0f0) * 60.0f0\n        z_increment = dive_velo_ms * Float32(dt)\n\n        if my_status == 0.0f0 && my_dives_remaining &gt; 0\n            my_interval += dt\n            max_fullness = 0.2f0 * my_biomass\n            fullness_ratio = max_fullness &gt; 0 ? my_fullness / max_fullness : 1.0f0\n            dive_prob = 1.0f0 - (1.0f0 / (1.0f0 + exp(-5.0f0 * (fullness_ratio - 0.5f0))))\n            if my_interval &gt;= surface_interval && rand(Float32) &lt; dive_prob\n                mig_status[ind] = 1.0f0\n                interval[ind] = 0.0f0\n                target_z[ind] = rand(Float32) * (dive_max - dive_min) + dive_min\n            else\n                interval[ind] = my_interval\n            end\n        elseif my_status == 1.0f0\n            z[ind] = min(target_z[ind], my_z + z_increment)\n            if z[ind] &gt;= target_z[ind]; mig_status[ind] = -1.0f0; end\n        elseif my_status == -1.0f0\n            my_interval += dt\n            if my_interval &gt;= dive_interval\n                mig_status[ind] = 2.0f0\n                interval[ind] = 0.0f0\n            else\n                interval[ind] = my_interval\n            end\n        elseif my_status == 2.0f0\n            z[ind] = max(1.0f0, my_z - z_increment)\n            if z[ind] &lt;= 1.0f0\n                mig_status[ind] = 0.0f0\n                dives_remaining[ind] -= 1\n            end\n        end\n        \n        @inbounds pool_z[ind] = clamp(ceil(Int, z[ind] / depth_res_m), 1, depthres)\n        @inbounds active[ind] += dt\n    end\nend\n\nfunction dive_action!(model::MarineModel, sp::Int)\n    arch = model.arch\n    data = model.individuals.animals[sp].data\n    p_cpu = model.individuals.animals[sp].p\n    \n    surface_interval = p_cpu.Surface_Interval.second[sp]\n    dive_interval = p_cpu.Dive_Interval.second[sp]\n    swim_velo = p_cpu.Swim_velo.second[sp]\n    dive_max = p_cpu.Dive_Max.second[sp]\n    dive_min = p_cpu.Dive_Min.second[sp]\n    \n    grid = model.depths.grid\n    depthres = Int(grid[grid.Name .== \"depthres\", :Value][1])\n    depth_res_m = grid[grid.Name .== \"depthmax\", :Value][1] / depthres\n\n    kernel! = dive_action_kernel!(device(arch), 256, (length(data.x),))\n    kernel!(\n        data.alive, data.mig_status, data.interval, data.z, data.dives_remaining,\n        data.gut_fullness, data.biomass_school, data.length, data.target_z,\n        data.pool_z, data.active,\n        surface_interval, dive_interval, swim_velo, dive_max, dive_min,\n        depth_res_m, depthres, model.t, model.dt\n    )\n    KernelAbstractions.synchronize(device(arch))\nend\n\n\n\n\nThis is the default movement behavior for agents that are not engaged in a specialized activity. It uses the “Gather, Compute, Update” pattern to remain architecture-compliant.\n\n\nThis function orchestrates the habitat-seeking process. It first gathers all necessary agent and environmental data from the GPU to the CPU. It then uses multi-threading to loop over each agent. For each agent, it determines a target location based on habitat quality and calculates a new position using the pathfinding helper functions. Finally, it copies the updated positions and active time back to the GPU.\n# ===================================================================\n# General Habitat-Seeking Movement\n# ===================================================================\n\nfunction movement_toward_habitat!(model::MarineModel, sp::Int, time::AbstractArray)\n    # --- 1. GATHER DATA FROM DEVICE TO CPU ---\n    arch = model.arch\n    animal_data = model.individuals.animals[sp].data\n    animal_param = model.individuals.animals[sp].p\n    \n    cpu_time = Array(time)\n    cpu_x, cpu_y = Array(animal_data.x), Array(animal_data.y)\n    cpu_pool_x, cpu_pool_y = Array(animal_data.pool_x), Array(animal_data.pool_y)\n    cpu_length = Array(animal_data.length)\n    cpu_alive = Array(animal_data.alive)\n    cpu_active = Array(animal_data.active)\n\n    new_x, new_y = copy(cpu_x), copy(cpu_y)\n    new_pool_x, new_pool_y = copy(cpu_pool_x), copy(cpu_pool_y)\n    \n    month = model.environment.ts\n    # The habitat array is (lon, lat)\n    habitat = Array(model.capacities[:, :, month, sp])\n    grid = model.depths.grid\n    latmax = grid[grid.Name .== \"yulcorner\", :Value][1]\n    lonmin = grid[grid.Name .== \"xllcorner\", :Value][1]\n    cell_size = grid[grid.Name .== \"cellsize\", :Value][1]\n    lonres, latres = size(habitat)\n\n    # Precompute list of all valid habitat cells across the entire grid\n    habitat_cells = [(x=i, y=j, value=habitat[i,j]) for i in 1:lonres, j in 1:latres if habitat[i,j] &gt; 0]\n    \n    if !isempty(habitat_cells)\n        sort!(habitat_cells, by = x -&gt; x.value, rev = true)\n        cumvals = cumsum(getfield.(habitat_cells, :value))\n        total_val = cumvals[end]\n\n        # --- 2. PERFORM MOVEMENT LOGIC ON CPU ---\n        Threads.@threads for ind in 1:length(cpu_x)\n            if cpu_alive[ind] == 1.0 && cpu_time[ind] &gt; 0\n                \n                cpu_active[ind] += cpu_time[ind] / 60.0\n\n                start_x, start_y = cpu_pool_x[ind], cpu_pool_y[ind]\n                cur_x, cur_y = cpu_x[ind], cpu_y[ind]\n                len_m = cpu_length[ind] / 1000.0\n                swim_speed_ms = bl_per_s(len_m*100, animal_param.Swim_velo[2][sp]) * len_m\n                max_dist = swim_speed_ms * cpu_time[ind]\n\n                # If agent is in unsuitable habitat, find the NEAREST valid cell\n                if habitat[start_x, start_y] == 0\n                    res = nearest_suitable_habitat(habitat, (cur_y, cur_x), (start_x, start_y), max_dist, latmax, lonmin, cell_size)\n                    if res !== nothing\n                        # Note: nearest_suitable_habitat returns (lat, lon, lon_idx, lat_idx)\n                        new_y[ind], new_x[ind], new_pool_x[ind], new_pool_y[ind] = res\n                    end\n                else\n                    # Agent is in suitable habitat, so it will pick a better spot globally\n                    r = (rand()^4) * total_val\n                    idx = findfirst(x -&gt; x &gt;= r, cumvals)\n                    if idx !== nothing\n                        target_x, target_y = habitat_cells[idx].x, habitat_cells[idx].y\n                        \n                        path = find_path(habitat, (start_x, start_y), (target_x, target_y))\n                        \n                        if path !== nothing && !isempty(path)\n                            # reachable_point returns (lat, lon, lat_idx, lon_idx)\n                            res_lat, res_lon, res_pool_y, res_pool_x = reachable_point((cur_y, cur_x), path, max_dist, latmax, lonmin, cell_size, lonres, latres)\n                            \n                            # Assign to the correct variables\n                            new_y[ind] = res_lat\n                            new_x[ind] = res_lon\n                            new_pool_y[ind] = res_pool_y\n                            new_pool_x[ind] = res_pool_x\n                        end\n                    end\n                end\n            end\n        end\n    end\n\n    # --- 3. UPDATE DEVICE ARRAYS WITH RESULTS ---\n    copyto!(animal_data.x, new_x)\n    copyto!(animal_data.y, new_y)\n    copyto!(animal_data.pool_x, new_pool_x)\n    copyto!(animal_data.pool_y, new_pool_y)\n    copyto!(animal_data.active, cpu_active)\n\n    return nothing\nend\n\n\n\n\nThis system is responsible for the monthly “shuffling” of the resource grids.\n\n\nThis high-level function is called from the main TimeStep! loop whenever a new month begins. It first calculates the total biomass for each resource species currently in the model. It then calls the move_resources_kernel! to redistribute this total biomass across the grid according to the habitat capacity map for the new month. This process ensures that resource availability tracks the seasonal changes in the environment.\n# ===================================================================\n# Monthly Resource Redistribution System\n# ===================================================================\n\n@kernel function move_resources_kernel!(\n    new_biomass_grid, capacities_for_month, \n    total_biomass_per_sp, total_capacity_per_sp\n)\n    lon, lat, depth = @index(Global, NTuple)\n    for sp in 1:size(new_biomass_grid, 4)\n        total_biomass = total_biomass_per_sp[sp]\n        total_capacity = total_capacity_per_sp[sp]\n        if total_biomass &gt; 0 && total_capacity &gt; 0\n            capacity_this_cell = capacities_for_month[lon, lat, sp]\n            if depth &lt;= 5\n                new_biomass = (capacity_this_cell / total_capacity) * total_biomass / 5.0\n                @inbounds new_biomass_grid[lon, lat, depth, sp] = new_biomass\n            else\n                @inbounds new_biomass_grid[lon, lat, depth, sp] = 0.0\n            end\n        else\n            @inbounds new_biomass_grid[lon, lat, depth, sp] = 0.0\n        end\n    end\nend\n\nfunction move_resources!(model::MarineModel, month::Int)\n    arch = model.arch\n    g = model.depths.grid\n    lonres = Int(g[g.Name .== \"lonres\", :Value][1])\n    latres = Int(g[g.Name .== \"latres\", :Value][1])\n    depthres = Int(g[g.Name .== \"depthres\", :Value][1])\n    n_res = model.n_resource\n    n_sp = model.n_species\n\n    total_biomass_per_sp = reshape(sum(model.resources.biomass, dims=(1,2,3)), n_res)\n    capacities_for_month = array_type(arch)(@view model.capacities[:, :, month, (n_sp+1):(n_sp+n_res)])\n    total_capacity_per_sp = reshape(sum(capacities_for_month, dims=(1,2)), n_res)\n    new_biomass_grid = array_type(arch)(zeros(Float64, lonres, latres, depthres, n_res))\n\n    kernel! = move_resources_kernel!(device(arch), (8,8,4), (lonres, latres, depthres))\n    kernel!(new_biomass_grid, capacities_for_month, total_biomass_per_sp, total_capacity_per_sp)\n    KernelAbstractions.synchronize(device(arch))\n\n    model.resources.biomass .= new_biomass_grid\n    model.resources.capacity .= new_biomass_grid\n    return nothing\nend",
    "crumbs": [
      "Model Components",
      "Movement Processes"
    ]
  },
  {
    "objectID": "components/fisheries.html",
    "href": "components/fisheries.html",
    "title": "SwimmingIndividuals.jl",
    "section": "",
    "text": "The fisheries.jl file contains all the functions related to the impact of human fishing activity on the simulated populations. This module is responsible for loading the complex regulations that define each fishery and for applying fishing mortality to the agents in a high-performance, parallel manner.\n\n\nAt the beginning of the simulation, the model needs to load and parse the rules for all the fisheries that will be active in the model world.\n\n\nThis function reads the fisheries.csv DataFrame, groups the data by the unique FisheryName, and constructs a Fishery object for each one. This object is a container for all the rules that govern that specific fishery, including its target and bycatch species, its annual quota, the start and end days of its season, the geographic area of its operation, and the gear selectivity parameters that determine which sizes of fish are most likely to be caught.\nfunction load_fisheries(df::DataFrame)\n    grouped = groupby(df, :FisheryName)\n    fisheries = Fishery[]\n\n    for g in grouped\n        name = g.FisheryName[1]\n        quota = g.Quota[1]\n        season = (g.StartDay[1], g.EndDay[1])\n        area = ((g.XMin[1], g.XMax[1]), (g.YMin[1], g.YMax[1]), (g.ZMin[1], g.ZMax[1]))\n        slot_limit = (g.SlotMin[1], g.SlotMax[1])\n        daily_bag_limit = g.BagLimit[1] * g.NVessel[1]\n\n        targets = g.Species[g.Role .== \"target\"]\n        bycatch = g.Species[g.Role .== \"bycatch\"]\n\n        selectivities = Dict{String, Selectivity}()\n        for row in eachrow(g)\n            selectivities[row.Species] = Selectivity(row.Species, row.L50, row.Slope)\n        end\n\n        push!(fisheries, Fishery(\n            name,\n            collect(targets),\n            collect(bycatch),\n            selectivities,\n            quota,\n            0.0,  # initialize cumulative catch\n            0,\n            season,\n            area,\n            slot_limit,\n            daily_bag_limit\n        ))\n    end\n    return fisheries\nend\n\n\n\n\nAt each timestep, the model must determine which agents are caught by the active fisheries. This is a computationally intensive task that is handled by a high-performance GPU kernel.\n\n\nThis is the main launcher function for the fishing submodel. It loops through each active fishery. For each one, it first performs a series of checks on the CPU to see if the fishery is open (i.e., within its season and under its quota). If it is, the function deconstructs the complex fishery object into a simple, GPU-compatible NamedTuple of parameters. It then calls the fishing_kernel! to run in parallel for all agents of the target species.\n\n\n\nThis GPU kernel is the core of the fishing model. Each thread handles a single agent. The kernel efficiently checks the agent against all the fishery’s regulations: its location (in_area), its size (in_slot), and a probabilistic gear selectivity curve. If an agent passes all these filters, the kernel calculates the number of individuals caught from its school (incorporating a density-dependent effect) and uses robust atomic operations to safely subtract the removed biomass and abundance from the agent’s state.\n@kernel function fishing_kernel!(\n    # Deconstructed agent data arrays\n    alive, x, y, z, length_arr, abundance, biomass_ind, biomass_school,\n    # Other arrays and parameters\n    Fmort_inds, spec_char_gpu, fishery_params_gpu, sp::Int\n)\n    ind = @index(Global)\n\n    @inbounds if alive[ind] == 1.0\n        # --- Filter 1: Is the agent in the right place? ---\n        in_area = (fishery_params_gpu.area[1][1] &lt;= x[ind] &lt;= fishery_params_gpu.area[1][2] &&\n                   fishery_params_gpu.area[2][1] &lt;= y[ind] &lt;= fishery_params_gpu.area[2][2] &&\n                   fishery_params_gpu.area[3][1] &lt;= z[ind] &lt;= fishery_params_gpu.area[3][2])\n\n        if in_area\n            # --- Filter 2: Is the agent the right size? ---\n            in_slot = fishery_params_gpu.slot_limit[1] &lt;= length_arr[ind] &lt;= fishery_params_gpu.slot_limit[2]\n\n            if in_slot\n                # --- Filter 3: Gear Selectivity (probabilistic) ---\n                selectivity = 1.0 / (1.0 + exp(-fishery_params_gpu.slope * (length_arr[ind] - fishery_params_gpu.l50)))\n                \n                if rand(Float32) &lt;= selectivity\n                    # --- ALL FILTERS PASSED: Calculate Catch ---\n                    abund = abundance[ind]\n                    k = spec_char_gpu.School_Size[sp] / 2.0\n                    density_effect = abund^2 / (abund^2 + k^2)\n                    \n                    possible_inds = floor(Int, abund)\n                    catch_inds = floor(Int, rand(Float32) * possible_inds * density_effect)\n\n                    if catch_inds &gt; 0\n                        biomass_removed = catch_inds * biomass_ind[ind]\n                        \n                        # --- FIX: Use a robust atomic subtraction and correction pattern ---\n                        # This avoids the complex CAS loop and is guaranteed to be GPU-compliant.\n                        \n                        # Atomically subtract the desired amount. This returns the ORIGINAL value.\n                        old_biomass = @atomic biomass_school[ind] -= biomass_removed\n                        \n                        # Now, check if we overdrew the account (subtracted more than was available)\n                        if old_biomass &lt; biomass_removed\n                            # We took too much. Atomically add back the difference to set biomass to zero.\n                            biomass_to_return = biomass_removed - old_biomass\n                            @atomic biomass_school[ind] += biomass_to_return\n                        end\n                        \n                        # The actual amount of biomass successfully removed is the minimum of what we wanted and what was there.\n                        actual_biomass_removed = min(biomass_removed, old_biomass)\n\n                        if actual_biomass_removed &gt; 0\n                            actual_inds_caught = floor(Int, actual_biomass_removed / biomass_ind[ind])\n                            \n                            if actual_inds_caught &gt; 0\n                                old_abund = @atomic abundance[ind] -= Float64(actual_inds_caught)\n                                if old_abund - actual_inds_caught &lt;= 0\n                                    alive[ind] = 0.0\n                                end\n                                @atomic Fmort_inds[ind] += actual_inds_caught\n                            end\n                        end\n                    end\n                end\n            end\n        end\n    end\nend\n\n\n# LAUNCHER: Deconstructs complex objects before calling the kernel\nfunction fishing!(model::MarineModel, sp::Int, day::Int, outputs::MarineOutputs)\n    arch = model.arch\n    spec_dat = model.individuals.animals[sp].data\n    spec_char_cpu = model.individuals.animals[sp].p\n    spec_name = spec_char_cpu.SpeciesLong.second[sp]\n\n    Fmort_inds = array_type(arch)(zeros(Int, length(spec_dat.x)))\n    spec_char_gpu = (; (k =&gt; array_type(arch)(v.second) for (k, v) in pairs(spec_char_cpu))...)\n\n    for (fish_idx, fishery) in enumerate(model.fishing)\n        if !(fishery.season[1] &lt;= day &lt;= fishery.season[2]) || fishery.cumulative_catch &gt;= fishery.quota\n            continue\n        end\n        if !(spec_name in fishery.target_species || spec_name in fishery.bycatch_species)\n            continue\n        end\n\n        sel = fishery.selectivities[spec_name]\n        fishery_params_gpu = (\n            area = fishery.area,\n            slot_limit = fishery.slot_limit,\n            l50 = sel.L50,\n            slope = sel.slope\n        )\n\n        kernel! = fishing_kernel!(device(arch), 256, (length(spec_dat.x),))\n        \n        # Launch the kernel with deconstructed arrays\n        kernel!(\n            spec_dat.alive, spec_dat.x, spec_dat.y, spec_dat.z, spec_dat.length,\n            spec_dat.abundance, spec_dat.biomass_ind, spec_dat.biomass_school,\n            Fmort_inds, spec_char_gpu, fishery_params_gpu, sp\n        )\n\n        total_inds_caught = Int(sum(Fmort_inds))\n        if total_inds_caught &gt; 0\n            cpu_biomass_ind = Array(spec_dat.biomass_ind)\n            cpu_fmort_inds = Array(Fmort_inds)\n            avg_biomass_ind = mean(cpu_biomass_ind[cpu_fmort_inds .&gt; 0])\n            total_biomass_caught = total_inds_caught * avg_biomass_ind\n            \n            fishery.cumulative_inds += total_inds_caught\n            fishery.cumulative_catch += total_biomass_caught / 1e6\n            \n            fill!(Fmort_inds, 0)\n        end\n    end\n    KernelAbstractions.synchronize(device(arch))\nend",
    "crumbs": [
      "Model Components",
      "Fisheries"
    ]
  },
  {
    "objectID": "components/fisheries.html#fisheries",
    "href": "components/fisheries.html#fisheries",
    "title": "SwimmingIndividuals.jl",
    "section": "",
    "text": "The fisheries.jl file contains all the functions related to the impact of human fishing activity on the simulated populations. This module is responsible for loading the complex regulations that define each fishery and for applying fishing mortality to the agents in a high-performance, parallel manner.\n\n\nAt the beginning of the simulation, the model needs to load and parse the rules for all the fisheries that will be active in the model world.\n\n\nThis function reads the fisheries.csv DataFrame, groups the data by the unique FisheryName, and constructs a Fishery object for each one. This object is a container for all the rules that govern that specific fishery, including its target and bycatch species, its annual quota, the start and end days of its season, the geographic area of its operation, and the gear selectivity parameters that determine which sizes of fish are most likely to be caught.\nfunction load_fisheries(df::DataFrame)\n    grouped = groupby(df, :FisheryName)\n    fisheries = Fishery[]\n\n    for g in grouped\n        name = g.FisheryName[1]\n        quota = g.Quota[1]\n        season = (g.StartDay[1], g.EndDay[1])\n        area = ((g.XMin[1], g.XMax[1]), (g.YMin[1], g.YMax[1]), (g.ZMin[1], g.ZMax[1]))\n        slot_limit = (g.SlotMin[1], g.SlotMax[1])\n        daily_bag_limit = g.BagLimit[1] * g.NVessel[1]\n\n        targets = g.Species[g.Role .== \"target\"]\n        bycatch = g.Species[g.Role .== \"bycatch\"]\n\n        selectivities = Dict{String, Selectivity}()\n        for row in eachrow(g)\n            selectivities[row.Species] = Selectivity(row.Species, row.L50, row.Slope)\n        end\n\n        push!(fisheries, Fishery(\n            name,\n            collect(targets),\n            collect(bycatch),\n            selectivities,\n            quota,\n            0.0,  # initialize cumulative catch\n            0,\n            season,\n            area,\n            slot_limit,\n            daily_bag_limit\n        ))\n    end\n    return fisheries\nend\n\n\n\n\nAt each timestep, the model must determine which agents are caught by the active fisheries. This is a computationally intensive task that is handled by a high-performance GPU kernel.\n\n\nThis is the main launcher function for the fishing submodel. It loops through each active fishery. For each one, it first performs a series of checks on the CPU to see if the fishery is open (i.e., within its season and under its quota). If it is, the function deconstructs the complex fishery object into a simple, GPU-compatible NamedTuple of parameters. It then calls the fishing_kernel! to run in parallel for all agents of the target species.\n\n\n\nThis GPU kernel is the core of the fishing model. Each thread handles a single agent. The kernel efficiently checks the agent against all the fishery’s regulations: its location (in_area), its size (in_slot), and a probabilistic gear selectivity curve. If an agent passes all these filters, the kernel calculates the number of individuals caught from its school (incorporating a density-dependent effect) and uses robust atomic operations to safely subtract the removed biomass and abundance from the agent’s state.\n@kernel function fishing_kernel!(\n    # Deconstructed agent data arrays\n    alive, x, y, z, length_arr, abundance, biomass_ind, biomass_school,\n    # Other arrays and parameters\n    Fmort_inds, spec_char_gpu, fishery_params_gpu, sp::Int\n)\n    ind = @index(Global)\n\n    @inbounds if alive[ind] == 1.0\n        # --- Filter 1: Is the agent in the right place? ---\n        in_area = (fishery_params_gpu.area[1][1] &lt;= x[ind] &lt;= fishery_params_gpu.area[1][2] &&\n                   fishery_params_gpu.area[2][1] &lt;= y[ind] &lt;= fishery_params_gpu.area[2][2] &&\n                   fishery_params_gpu.area[3][1] &lt;= z[ind] &lt;= fishery_params_gpu.area[3][2])\n\n        if in_area\n            # --- Filter 2: Is the agent the right size? ---\n            in_slot = fishery_params_gpu.slot_limit[1] &lt;= length_arr[ind] &lt;= fishery_params_gpu.slot_limit[2]\n\n            if in_slot\n                # --- Filter 3: Gear Selectivity (probabilistic) ---\n                selectivity = 1.0 / (1.0 + exp(-fishery_params_gpu.slope * (length_arr[ind] - fishery_params_gpu.l50)))\n                \n                if rand(Float32) &lt;= selectivity\n                    # --- ALL FILTERS PASSED: Calculate Catch ---\n                    abund = abundance[ind]\n                    k = spec_char_gpu.School_Size[sp] / 2.0\n                    density_effect = abund^2 / (abund^2 + k^2)\n                    \n                    possible_inds = floor(Int, abund)\n                    catch_inds = floor(Int, rand(Float32) * possible_inds * density_effect)\n\n                    if catch_inds &gt; 0\n                        biomass_removed = catch_inds * biomass_ind[ind]\n                        \n                        # --- FIX: Use a robust atomic subtraction and correction pattern ---\n                        # This avoids the complex CAS loop and is guaranteed to be GPU-compliant.\n                        \n                        # Atomically subtract the desired amount. This returns the ORIGINAL value.\n                        old_biomass = @atomic biomass_school[ind] -= biomass_removed\n                        \n                        # Now, check if we overdrew the account (subtracted more than was available)\n                        if old_biomass &lt; biomass_removed\n                            # We took too much. Atomically add back the difference to set biomass to zero.\n                            biomass_to_return = biomass_removed - old_biomass\n                            @atomic biomass_school[ind] += biomass_to_return\n                        end\n                        \n                        # The actual amount of biomass successfully removed is the minimum of what we wanted and what was there.\n                        actual_biomass_removed = min(biomass_removed, old_biomass)\n\n                        if actual_biomass_removed &gt; 0\n                            actual_inds_caught = floor(Int, actual_biomass_removed / biomass_ind[ind])\n                            \n                            if actual_inds_caught &gt; 0\n                                old_abund = @atomic abundance[ind] -= Float64(actual_inds_caught)\n                                if old_abund - actual_inds_caught &lt;= 0\n                                    alive[ind] = 0.0\n                                end\n                                @atomic Fmort_inds[ind] += actual_inds_caught\n                            end\n                        end\n                    end\n                end\n            end\n        end\n    end\nend\n\n\n# LAUNCHER: Deconstructs complex objects before calling the kernel\nfunction fishing!(model::MarineModel, sp::Int, day::Int, outputs::MarineOutputs)\n    arch = model.arch\n    spec_dat = model.individuals.animals[sp].data\n    spec_char_cpu = model.individuals.animals[sp].p\n    spec_name = spec_char_cpu.SpeciesLong.second[sp]\n\n    Fmort_inds = array_type(arch)(zeros(Int, length(spec_dat.x)))\n    spec_char_gpu = (; (k =&gt; array_type(arch)(v.second) for (k, v) in pairs(spec_char_cpu))...)\n\n    for (fish_idx, fishery) in enumerate(model.fishing)\n        if !(fishery.season[1] &lt;= day &lt;= fishery.season[2]) || fishery.cumulative_catch &gt;= fishery.quota\n            continue\n        end\n        if !(spec_name in fishery.target_species || spec_name in fishery.bycatch_species)\n            continue\n        end\n\n        sel = fishery.selectivities[spec_name]\n        fishery_params_gpu = (\n            area = fishery.area,\n            slot_limit = fishery.slot_limit,\n            l50 = sel.L50,\n            slope = sel.slope\n        )\n\n        kernel! = fishing_kernel!(device(arch), 256, (length(spec_dat.x),))\n        \n        # Launch the kernel with deconstructed arrays\n        kernel!(\n            spec_dat.alive, spec_dat.x, spec_dat.y, spec_dat.z, spec_dat.length,\n            spec_dat.abundance, spec_dat.biomass_ind, spec_dat.biomass_school,\n            Fmort_inds, spec_char_gpu, fishery_params_gpu, sp\n        )\n\n        total_inds_caught = Int(sum(Fmort_inds))\n        if total_inds_caught &gt; 0\n            cpu_biomass_ind = Array(spec_dat.biomass_ind)\n            cpu_fmort_inds = Array(Fmort_inds)\n            avg_biomass_ind = mean(cpu_biomass_ind[cpu_fmort_inds .&gt; 0])\n            total_biomass_caught = total_inds_caught * avg_biomass_ind\n            \n            fishery.cumulative_inds += total_inds_caught\n            fishery.cumulative_catch += total_biomass_caught / 1e6\n            \n            fill!(Fmort_inds, 0)\n        end\n    end\n    KernelAbstractions.synchronize(device(arch))\nend",
    "crumbs": [
      "Model Components",
      "Fisheries"
    ]
  },
  {
    "objectID": "components/energy.html",
    "href": "components/energy.html",
    "title": "SwimmingIndividuals.jl",
    "section": "",
    "text": "The energy.jl file is the physiological engine of the model. It contains the energy! function, which is responsible for calculating the complete energy budget for every living agent at each timestep. This is where consumption is converted into growth and reproduction, and where the costs of living are paid.\n\n\nBecause the bioenergetics calculations are complex and state-dependent, they are performed on the CPU using multi-threading for speed. To make this compatible with a GPU-based simulation, the energy! function uses a robust “Gather, Compute, Update” pattern:\n\nGather: All necessary agent data is copied from the GPU to CPU memory at the beginning of the function.\nCompute: The main for loop iterates over all agents on the CPU, performing the detailed bioenergetics calculations.\nUpdate: The final, updated agent data is copied back from the CPU to the GPU in a single, efficient batch operation.\n\n\n\n\nFor each living agent, the function performs the following key tasks:\n\nCalculate Respiration: It calculates the total respiratory cost (R) based on the agent’s weight, temperature, and activity level. The model is flexible and can use different respiration models based on the species’ MR_type (e.g., for standard fish, cetaceans, or deep-sea organisms).\nBalance Energy Budget: It calculates the net energy gain or loss for the timestep based on the “Wisconsin” bioenergetics model (Consumption = Respiration + Waste + Growth + Reproduction).\nAllocate Surplus Energy: Any surplus energy is first allocated to somatic growth, increasing the agent’s biomass. Any remaining excess is then allocated to reproductive energy, but only if the agent is mature and in its designated spawning season.\nApply Starvation: If an agent’s energy balance is negative, it is subject to starvation mortality, and its alive status is set to 0.0.\nTrigger Reproduction: After the main loop, it calls the process_reproduction! function (from create.jl) to handle the creation of new offspring from parents that have accumulated reproductive energy.\n\n\n\n\n```julia function energy!(model::MarineModel, sp::Int, temp::AbstractArray, indices) arch = model.arch p_cpu = model.individuals.animals[sp].p dt = model.dt\n# --- 1. GATHER DATA FROM DEVICE (GPU) TO HOST (CPU) ---\n# Reconstruct the StructArray on the CPU by copying each column individually.\nagent_data_device = model.individuals.animals[sp].data\ndata_cpu = StructArray(\n    x = Array(agent_data_device.x), y = Array(agent_data_device.y), z = Array(agent_data_device.z),\n    length = Array(agent_data_device.length), abundance = Array(agent_data_device.abundance),\n    biomass_ind = Array(agent_data_device.biomass_ind), biomass_school = Array(agent_data_device.biomass_school),\n    energy = Array(agent_data_device.energy), gut_fullness = Array(agent_data_device.gut_fullness),\n    cost = Array(agent_data_device.cost), pool_x = Array(agent_data_device.pool_x),\n    pool_y = Array(agent_data_device.pool_y), pool_z = Array(agent_data_device.pool_z),\n    active = Array(agent_data_device.active), ration = Array(agent_data_device.ration),\n    alive = Array(agent_data_device.alive), vis_prey = Array(agent_data_device.vis_prey),\n    mature = Array(agent_data_device.mature), age = Array(agent_data_device.age),\n    cell_id = Array(agent_data_device.cell_id), sorted_id = Array(agent_data_device.sorted_id),\n    repro_energy = Array(agent_data_device.repro_energy),\n    best_prey_dist = Array(agent_data_device.best_prey_dist),\n    best_prey_idx = Array(agent_data_device.best_prey_idx),\n    best_prey_sp = Array(agent_data_device.best_prey_sp),\n    best_prey_type = Array(agent_data_device.best_prey_type),\n    successful_ration = Array(agent_data_device.successful_ration),\n    temp_idx = Array(agent_data_device.temp_idx),\n    cell_starts = Array(agent_data_device.cell_starts),\n    cell_ends = Array(agent_data_device.cell_ends),\n    mig_status = Array(agent_data_device.mig_status),\n    target_z = Array(agent_data_device.target_z),\n    interval = Array(agent_data_device.interval),\n    dives_remaining = Array(agent_data_device.dives_remaining),\n)\ntemp_cpu = Array(temp)\n\n# --- 2. COMPUTE BIOENERGETICS ON CPU ---\n# Get seasonal reproduction value\nspawn_season = CSV.read(model.files[model.files.File .== \"reproduction\", :Destination][1], DataFrame)\nspecies_name = p_cpu.SpeciesLong.second[sp]\nrow_idx = findfirst(==(species_name), spawn_season.Species)\nspawn_val = row_idx !== nothing ? spawn_season[row_idx, model.environment.ts + 1] : 0.0\n\nspinup_check = model.iteration &gt; model.spinup\n\n# Use CPU multi-threading for the main calculation loop\n@Threads.threads for ind in 1:length(data_cpu.x)\n    if data_cpu.alive[ind] == 1.0\n        # --- Gather Agent Properties (from CPU copies) ---\n        my_temp = temp_cpu[ind]\n        my_consumed = data_cpu.ration[ind]\n        my_weight = data_cpu.biomass_school[ind]\n        my_active_time = min(1.0, data_cpu.active[ind] / dt)\n        my_z = data_cpu.z[ind]\n        my_length = data_cpu.length[ind]\n        my_energy = data_cpu.energy[ind]\n        my_mature = data_cpu.mature[ind]\n\n        # Get Species-Specific Trait Codes\n        energy_ed = p_cpu.Energy_density.second[sp]\n        taxa_code = p_cpu.Taxa.second[sp]\n        energy_type_code = p_cpu.MR_type.second[sp]\n        max_size = p_cpu.Max_Size.second[sp]\n\n        # --- Respiration (R) ---\n        R = 0.0\n        if energy_type_code == 2 # \"cetacean\"\n            min_fmr = (350.0 * (my_weight / 1000.0)^0.75) * (dt / 1440.0) / 4184.0\n            max_fmr = (420.0 * (my_weight / 1000.0)^0.75) * (dt / 1440.0) / 4184.0\n            R = min_fmr + (max_fmr - min_fmr) * my_active_time\n        elseif energy_type_code == 3 # \"deepsea\"\n            oxy = 13.6\n            depth = max(1.0, my_z)\n            if my_weight &gt; 0; log_weight = log(my_weight); else continue; end\n            inv_temp = 1000.0 / (273.15 + my_temp)\n            log_depth = log(depth)\n            lnr = (taxa_code == 1 ? 19.491 + 0.885 * log_weight - 5.770 * inv_temp - 0.261 * log_depth :\n                   taxa_code == 2 ? 28.326 + 0.779 * log_weight - 7.903 * inv_temp - 0.365 * log_depth :\n                   18.775 + 0.766 * log_weight - 5.265 * inv_temp - 0.113 * log_depth)\n            R = (exp(lnr) / 1140.0 * (oxy * 1000.0)) / 60.0 * dt\n        else # Default\n            R0 = 0.02; k = 8.617e-5; TK = my_temp + 273.15\n            rmr = R0 * my_weight^0.75 * exp(-0.65 / (k * TK))\n            R = ((rmr / 2.0) * (1.0 - my_active_time)) + (rmr * my_active_time)\n        end\n\n        # --- Net Energy and Gut Evacuation ---\n        sda_coeff, egestion_coeff, excretion_coeff = 0.05, 0.1, 0.05\n        total_waste_and_cost = R + (my_consumed * (sda_coeff + egestion_coeff + excretion_coeff))\n        net_energy = my_consumed - total_waste_and_cost\n        \n        if ismissing(total_waste_and_cost)\n            continue\n        end\n        data_cpu.cost[ind] = total_waste_and_cost\n\n        my_energy += net_energy\n\n        evac_prop = min(1.0, 0.053 * exp(0.073 * my_temp))\n        if evac_prop &lt; 1.0\n            data_cpu.gut_fullness[ind] *= exp((dt / 60.0) * log(1.0 - evac_prop))\n        else\n            data_cpu.gut_fullness[ind] = 0.0\n        end\n\n        # --- Growth & Reproduction ---\n        r_max = my_weight * energy_ed * 0.2\n        excess = max(0.0, my_energy - r_max)\n        my_energy = min(r_max, my_energy)\n\n        if my_length &lt; max_size && excess &gt; 0.0\n            growth_prop = exp(-5.0 * my_length / max_size)\n            growth_energy = excess * growth_prop\n            new_biomass = data_cpu.biomass_school[ind] + (growth_energy / energy_ed)\n            data_cpu.biomass_school[ind] = new_biomass\n            my_energy -= growth_energy\n            excess -= growth_energy\n        end\n\n        if my_mature == 1.0 && excess &gt; 0.0 && spawn_val &gt; 0.0\n            data_cpu.repro_energy[ind] = excess\n            my_energy -= excess\n        end\n\n        data_cpu.energy[ind] = my_energy\n        \n        # --- Starvation ---\n        if my_energy &lt; 0.0 && spinup_check\n            data_cpu.alive[ind] = 0.0\n        end\n    end\nend\n\n# --- Process Reproduction on the CPU ---\nrepro_inds = findall(data_cpu.repro_energy .&gt; 0)\nif !isempty(repro_inds)\n    parent_data_for_repro = (\n        x = data_cpu.x[repro_inds], y = data_cpu.y[repro_inds], z = data_cpu.z[repro_inds],\n        pool_x = data_cpu.pool_x[repro_inds], pool_y = data_cpu.pool_y[repro_inds], pool_z = data_cpu.pool_z[repro_inds],\n        biomass_ind = data_cpu.biomass_ind[repro_inds]\n    )\n    new_offspring = calculate_new_offspring_cpu(p_cpu, parent_data_for_repro, data_cpu.repro_energy[repro_inds], spawn_val,sp)\n    \n    if new_offspring !== nothing\n        num_new = length(new_offspring.x)\n        if num_new &gt; 0\n            dead_slots = findall(data_cpu.alive .== 0)\n            num_to_add = min(num_new, length(dead_slots))\n            if num_to_add &gt; 0\n                slots_to_fill = @view dead_slots[1:num_to_add]\n                for (field, values) in pairs(new_offspring)\n                    getproperty(data_cpu, field)[slots_to_fill] .= @view(values[1:num_to_add])\n                end\n                data_cpu.alive[slots_to_fill] .= 1.0\n            end\n        end\n        data_cpu.repro_energy[repro_inds] .= 0.0\n    end\nend\n\n# --- 3. UPDATE: Copy the modified CPU data back to the original device array ---\ncopyto!(model.individuals.animals[sp].data, data_cpu)\n\nreturn nothing\nend",
    "crumbs": [
      "Model Components",
      "Energy Budget"
    ]
  },
  {
    "objectID": "components/energy.html#energy-budget",
    "href": "components/energy.html#energy-budget",
    "title": "SwimmingIndividuals.jl",
    "section": "",
    "text": "The energy.jl file is the physiological engine of the model. It contains the energy! function, which is responsible for calculating the complete energy budget for every living agent at each timestep. This is where consumption is converted into growth and reproduction, and where the costs of living are paid.\n\n\nBecause the bioenergetics calculations are complex and state-dependent, they are performed on the CPU using multi-threading for speed. To make this compatible with a GPU-based simulation, the energy! function uses a robust “Gather, Compute, Update” pattern:\n\nGather: All necessary agent data is copied from the GPU to CPU memory at the beginning of the function.\nCompute: The main for loop iterates over all agents on the CPU, performing the detailed bioenergetics calculations.\nUpdate: The final, updated agent data is copied back from the CPU to the GPU in a single, efficient batch operation.\n\n\n\n\nFor each living agent, the function performs the following key tasks:\n\nCalculate Respiration: It calculates the total respiratory cost (R) based on the agent’s weight, temperature, and activity level. The model is flexible and can use different respiration models based on the species’ MR_type (e.g., for standard fish, cetaceans, or deep-sea organisms).\nBalance Energy Budget: It calculates the net energy gain or loss for the timestep based on the “Wisconsin” bioenergetics model (Consumption = Respiration + Waste + Growth + Reproduction).\nAllocate Surplus Energy: Any surplus energy is first allocated to somatic growth, increasing the agent’s biomass. Any remaining excess is then allocated to reproductive energy, but only if the agent is mature and in its designated spawning season.\nApply Starvation: If an agent’s energy balance is negative, it is subject to starvation mortality, and its alive status is set to 0.0.\nTrigger Reproduction: After the main loop, it calls the process_reproduction! function (from create.jl) to handle the creation of new offspring from parents that have accumulated reproductive energy.\n\n\n\n\n```julia function energy!(model::MarineModel, sp::Int, temp::AbstractArray, indices) arch = model.arch p_cpu = model.individuals.animals[sp].p dt = model.dt\n# --- 1. GATHER DATA FROM DEVICE (GPU) TO HOST (CPU) ---\n# Reconstruct the StructArray on the CPU by copying each column individually.\nagent_data_device = model.individuals.animals[sp].data\ndata_cpu = StructArray(\n    x = Array(agent_data_device.x), y = Array(agent_data_device.y), z = Array(agent_data_device.z),\n    length = Array(agent_data_device.length), abundance = Array(agent_data_device.abundance),\n    biomass_ind = Array(agent_data_device.biomass_ind), biomass_school = Array(agent_data_device.biomass_school),\n    energy = Array(agent_data_device.energy), gut_fullness = Array(agent_data_device.gut_fullness),\n    cost = Array(agent_data_device.cost), pool_x = Array(agent_data_device.pool_x),\n    pool_y = Array(agent_data_device.pool_y), pool_z = Array(agent_data_device.pool_z),\n    active = Array(agent_data_device.active), ration = Array(agent_data_device.ration),\n    alive = Array(agent_data_device.alive), vis_prey = Array(agent_data_device.vis_prey),\n    mature = Array(agent_data_device.mature), age = Array(agent_data_device.age),\n    cell_id = Array(agent_data_device.cell_id), sorted_id = Array(agent_data_device.sorted_id),\n    repro_energy = Array(agent_data_device.repro_energy),\n    best_prey_dist = Array(agent_data_device.best_prey_dist),\n    best_prey_idx = Array(agent_data_device.best_prey_idx),\n    best_prey_sp = Array(agent_data_device.best_prey_sp),\n    best_prey_type = Array(agent_data_device.best_prey_type),\n    successful_ration = Array(agent_data_device.successful_ration),\n    temp_idx = Array(agent_data_device.temp_idx),\n    cell_starts = Array(agent_data_device.cell_starts),\n    cell_ends = Array(agent_data_device.cell_ends),\n    mig_status = Array(agent_data_device.mig_status),\n    target_z = Array(agent_data_device.target_z),\n    interval = Array(agent_data_device.interval),\n    dives_remaining = Array(agent_data_device.dives_remaining),\n)\ntemp_cpu = Array(temp)\n\n# --- 2. COMPUTE BIOENERGETICS ON CPU ---\n# Get seasonal reproduction value\nspawn_season = CSV.read(model.files[model.files.File .== \"reproduction\", :Destination][1], DataFrame)\nspecies_name = p_cpu.SpeciesLong.second[sp]\nrow_idx = findfirst(==(species_name), spawn_season.Species)\nspawn_val = row_idx !== nothing ? spawn_season[row_idx, model.environment.ts + 1] : 0.0\n\nspinup_check = model.iteration &gt; model.spinup\n\n# Use CPU multi-threading for the main calculation loop\n@Threads.threads for ind in 1:length(data_cpu.x)\n    if data_cpu.alive[ind] == 1.0\n        # --- Gather Agent Properties (from CPU copies) ---\n        my_temp = temp_cpu[ind]\n        my_consumed = data_cpu.ration[ind]\n        my_weight = data_cpu.biomass_school[ind]\n        my_active_time = min(1.0, data_cpu.active[ind] / dt)\n        my_z = data_cpu.z[ind]\n        my_length = data_cpu.length[ind]\n        my_energy = data_cpu.energy[ind]\n        my_mature = data_cpu.mature[ind]\n\n        # Get Species-Specific Trait Codes\n        energy_ed = p_cpu.Energy_density.second[sp]\n        taxa_code = p_cpu.Taxa.second[sp]\n        energy_type_code = p_cpu.MR_type.second[sp]\n        max_size = p_cpu.Max_Size.second[sp]\n\n        # --- Respiration (R) ---\n        R = 0.0\n        if energy_type_code == 2 # \"cetacean\"\n            min_fmr = (350.0 * (my_weight / 1000.0)^0.75) * (dt / 1440.0) / 4184.0\n            max_fmr = (420.0 * (my_weight / 1000.0)^0.75) * (dt / 1440.0) / 4184.0\n            R = min_fmr + (max_fmr - min_fmr) * my_active_time\n        elseif energy_type_code == 3 # \"deepsea\"\n            oxy = 13.6\n            depth = max(1.0, my_z)\n            if my_weight &gt; 0; log_weight = log(my_weight); else continue; end\n            inv_temp = 1000.0 / (273.15 + my_temp)\n            log_depth = log(depth)\n            lnr = (taxa_code == 1 ? 19.491 + 0.885 * log_weight - 5.770 * inv_temp - 0.261 * log_depth :\n                   taxa_code == 2 ? 28.326 + 0.779 * log_weight - 7.903 * inv_temp - 0.365 * log_depth :\n                   18.775 + 0.766 * log_weight - 5.265 * inv_temp - 0.113 * log_depth)\n            R = (exp(lnr) / 1140.0 * (oxy * 1000.0)) / 60.0 * dt\n        else # Default\n            R0 = 0.02; k = 8.617e-5; TK = my_temp + 273.15\n            rmr = R0 * my_weight^0.75 * exp(-0.65 / (k * TK))\n            R = ((rmr / 2.0) * (1.0 - my_active_time)) + (rmr * my_active_time)\n        end\n\n        # --- Net Energy and Gut Evacuation ---\n        sda_coeff, egestion_coeff, excretion_coeff = 0.05, 0.1, 0.05\n        total_waste_and_cost = R + (my_consumed * (sda_coeff + egestion_coeff + excretion_coeff))\n        net_energy = my_consumed - total_waste_and_cost\n        \n        if ismissing(total_waste_and_cost)\n            continue\n        end\n        data_cpu.cost[ind] = total_waste_and_cost\n\n        my_energy += net_energy\n\n        evac_prop = min(1.0, 0.053 * exp(0.073 * my_temp))\n        if evac_prop &lt; 1.0\n            data_cpu.gut_fullness[ind] *= exp((dt / 60.0) * log(1.0 - evac_prop))\n        else\n            data_cpu.gut_fullness[ind] = 0.0\n        end\n\n        # --- Growth & Reproduction ---\n        r_max = my_weight * energy_ed * 0.2\n        excess = max(0.0, my_energy - r_max)\n        my_energy = min(r_max, my_energy)\n\n        if my_length &lt; max_size && excess &gt; 0.0\n            growth_prop = exp(-5.0 * my_length / max_size)\n            growth_energy = excess * growth_prop\n            new_biomass = data_cpu.biomass_school[ind] + (growth_energy / energy_ed)\n            data_cpu.biomass_school[ind] = new_biomass\n            my_energy -= growth_energy\n            excess -= growth_energy\n        end\n\n        if my_mature == 1.0 && excess &gt; 0.0 && spawn_val &gt; 0.0\n            data_cpu.repro_energy[ind] = excess\n            my_energy -= excess\n        end\n\n        data_cpu.energy[ind] = my_energy\n        \n        # --- Starvation ---\n        if my_energy &lt; 0.0 && spinup_check\n            data_cpu.alive[ind] = 0.0\n        end\n    end\nend\n\n# --- Process Reproduction on the CPU ---\nrepro_inds = findall(data_cpu.repro_energy .&gt; 0)\nif !isempty(repro_inds)\n    parent_data_for_repro = (\n        x = data_cpu.x[repro_inds], y = data_cpu.y[repro_inds], z = data_cpu.z[repro_inds],\n        pool_x = data_cpu.pool_x[repro_inds], pool_y = data_cpu.pool_y[repro_inds], pool_z = data_cpu.pool_z[repro_inds],\n        biomass_ind = data_cpu.biomass_ind[repro_inds]\n    )\n    new_offspring = calculate_new_offspring_cpu(p_cpu, parent_data_for_repro, data_cpu.repro_energy[repro_inds], spawn_val,sp)\n    \n    if new_offspring !== nothing\n        num_new = length(new_offspring.x)\n        if num_new &gt; 0\n            dead_slots = findall(data_cpu.alive .== 0)\n            num_to_add = min(num_new, length(dead_slots))\n            if num_to_add &gt; 0\n                slots_to_fill = @view dead_slots[1:num_to_add]\n                for (field, values) in pairs(new_offspring)\n                    getproperty(data_cpu, field)[slots_to_fill] .= @view(values[1:num_to_add])\n                end\n                data_cpu.alive[slots_to_fill] .= 1.0\n            end\n        end\n        data_cpu.repro_energy[repro_inds] .= 0.0\n    end\nend\n\n# --- 3. UPDATE: Copy the modified CPU data back to the original device array ---\ncopyto!(model.individuals.animals[sp].data, data_cpu)\n\nreturn nothing\nend",
    "crumbs": [
      "Model Components",
      "Energy Budget"
    ]
  },
  {
    "objectID": "components/behavior.html",
    "href": "components/behavior.html",
    "title": "SwimmingIndividuals.jl",
    "section": "",
    "text": "The behavior.jl file is the “brain” of the agents. It contains the functions that govern how agents perceive their environment and how they make decisions. This module is called for every living agent at each timestep and is the entry point for all subsequent actions like predation and movement.\n\n\nAn agent’s ability to see prey is not a fixed radius but is mechanistically determined by the physics of light in water. This system calculates the visual range for each agent in parallel on the GPU.\n\n\nThis is the launcher function that orchestrates the visual range calculation. It first determines the current surface light intensity using the ipar_curve helper function. It then prepares the necessary agent and trait data and calls the visual_range_kernel! to perform the calculation for all agents of a given species.\n# ===================================================================\n# GPU-Compliant Visual Range Calculation\n# ===================================================================\n\n# Kernel to calculate the visual range for prey for each agent in parallel.\n@kernel function visual_range_kernel!(vis_out, length, depth, min_prey, max_prey, surface_irradiance)\n    ind = @index(Global)\n\n    # Constants for light attenuation and visual acuity\n    pred_contrast = 0.3\n    salt = 30.0\n    attenuation_coefficient = 0.64 - 0.016 * salt\n    \n    # Agent-specific properties\n    ind_length_m = length[ind] / 1000.0\n    rmax = ind_length_m * 30.0\n    \n    # Simplified image size calculation for kernel\n    pred_image = 0.75 * (ind_length_m / 0.01) * (ind_length_m / 4.0)\n    eye_sensitivity = (rmax^2) / (pred_image * pred_contrast)\n    \n    # Calculate light intensity at the agent's current depth\n    I_z = surface_irradiance * exp(-attenuation_coefficient * depth[ind])\n    \n    prey_size_factor = (min_prey + max_prey) / 2.0\n    \n    # Final visual range calculation based on light, eye sensitivity, and prey size\n    r_sq = (I_z * ind_length_m^2) / (pred_contrast * eye_sensitivity * prey_size_factor)\n    r = r_sq &gt; 0 ? sqrt(r_sq) : 0.0\n    \n    @inbounds vis_out[ind] = clamp(r, 0.0, rmax)\nend\n\n# Launcher for the visual range kernel.\nfunction update_visual_range!(model::MarineModel, sp::Int)\n    arch = model.arch\n    data = model.individuals.animals[sp].data\n    p = model.individuals.animals[sp].p\n    \n    surface_irradiance = ipar_curve(model.t)\n    \n    kernel! = visual_range_kernel!(device(arch), 256, (length(data.x),))\n    kernel!(\n        data.vis_prey, data.length, data.z,\n        p.Min_Prey[2][sp], p.Max_Prey[2][sp],\n        surface_irradiance\n    )\n    KernelAbstractions.synchronize(device(arch))\nend\n\n\n\n\nThese functions represent the high-level decision-making process for the agents.\n\n\nThis is the main behavioral dispatcher. It first calls update_visual_range! for the current species. It then checks the species’ behavioral archetype (e.g., “dvm_strong”, “pelagic_diver”) and routes the agents to the appropriate specialized movement function (dvm_action! or dive_action!). Crucially, it then calls the decision function for any agents that are not currently engaged in a specialized, overriding behavior (like migrating).\n\n\n\nThis is the core foraging logic. For a given subset of agents, it calculates a “feed trigger” based on their gut fullness. It then uses a probabilistic check to determine which of these agents will attempt to forage during the current timestep. For those agents that decide to eat, it orchestrates the full predation sequence by calling calculate_distances_prey!, resolve_consumption!, and apply_consumption!. Finally, it calls movement_toward_habitat! for all agents in the subset, allowing them to use any time remaining in the timestep to move towards better habitat.\n# ===================================================================\n# Core Behavioral Functions\n# ===================================================================\n\n# Main behavioral dispatcher.\nfunction behavior(model::MarineModel, sp::Int, ind::Vector{Int}, outputs::MarineOutputs)\n    behave_type = model.individuals.animals[sp].p.Type[2][sp]\n    sp_dat = model.individuals.animals[sp].data\n    \n    # Update visual range for all agents of this species first\n    update_visual_range!(model, sp)\n\n    if behave_type == \"dvm_strong\"\n        dvm_action!(model, sp) # This kernel runs on all agents\n        \n        # Find which agents are NOT migrating to pass them to the decision function\n        mig_status_cpu = Array(sp_dat.mig_status)\n        not_migrating_indices = findall(x -&gt; x &lt;= 0.0, mig_status_cpu)\n        \n        # Intersect with the list of currently living agents\n        decision_inds = intersect(ind, not_migrating_indices)\n        \n        if !isempty(decision_inds)\n            decision(model, sp, decision_inds, outputs)\n        end\n\n    elseif behave_type == \"dvm_weak\"\n        dvm_action!(model, sp)\n        decision(model, sp, ind, outputs)\n\n    elseif behave_type == \"pelagic_diver\"\n        dive_action!(model, sp)\n        decision(model, sp, ind, outputs)\n        \n    elseif behave_type == \"non_mig\"\n        decision(model, sp, ind, outputs)\n    end\n    \n    return nothing\nend\n\n\n# Core decision-making function for foraging and movement.\nfunction decision(model::MarineModel, sp::Int, ind::Vector{Int64}, outputs::MarineOutputs)\n    sp_dat = model.individuals.animals[sp].data\n    arch = model.arch\n\n    # Create views to work with the subset of individuals\n    gut_fullness_view = @view sp_dat.gut_fullness[ind]\n    biomass_school_view = @view sp_dat.biomass_school[ind]\n\n    max_fullness = 0.2 .* biomass_school_view\n    feed_trigger = gut_fullness_view ./ max_fullness\n    \n    # Generate random numbers on the correct device\n    local val1\n    if arch isa GPU\n        val1 = CUDA.rand(Float32, length(ind))\n    else\n        val1 = rand(Float32, length(ind))\n    end\n\n    # Create a boolean mask on the GPU, copy it to CPU, then findall\n    eat_mask_gpu = (feed_trigger .&lt;= val1)\n    eat_mask_cpu = Array(eat_mask_gpu)\n    to_eat_indices = findall(eat_mask_cpu)\n\n    eating = ind[to_eat_indices]\n    \n    # Create the 'time' vector on the correct device\n    time = array_type(arch)(zeros(Float32, length(sp_dat.alive)))\n    time .= Float32(model.dt * 60.0)\n\n    if !isempty(eating)\n        # --- Predation Sequence ---\n        print(\"find prey | \")\n        calculate_distances_prey!(model, sp, eating)\n        \n        resolve_consumption!(model, sp, eating)\n        \n        print(\"eat | \")\n        apply_consumption!(model, sp, time,outputs)\n    end\n\n    print(\"move | \")\n    movement_toward_habitat!(model, sp, time)\n    \n    return nothing\nend\n\n\n\n\nThese are CPU-based versions of the visual range calculation that are used only once, during the model initialization, to set the starting visual range for newly created agents.\n# ===================================================================\n# CPU-based Initialization Functions (used only during setup)\n# ===================================================================\n\nfunction visual_range_preds_init(length,depth,min_pred,max_pred,ind)\n    pred_contrast = fill(0.3,ind)\n    salt = fill(30, ind)\n    attenuation_coefficient = 0.64 .- 0.016 .* salt\n    ind_length = length ./ 1000\n    pred_length = ind_length ./ 0.01\n    pred_width = pred_length ./ 4\n    pred_image = 0.75 .* pred_length .* pred_width\n    rmax = ind_length .* 30\n    eye_sensitivity = (rmax.^2) ./ (pred_image .* pred_contrast)\n    surface_irradiance = ipar_curve(0)\n    I_z = surface_irradiance .* exp.(-attenuation_coefficient .* depth)\n    pred_size_factor = 1+((min_pred+max_pred)/2)\n    r = max.(1,ind_length .* sqrt.(I_z ./ (pred_contrast .* eye_sensitivity .* pred_size_factor)))\n    return r\nend\n\nfunction visual_range_preys_init(length,depth,min_prey,max_prey,ind)\n    pred_contrast = fill(0.3,ind)\n    salt = fill(30, ind)\n    attenuation_coefficient = 0.64 .- 0.016 .* salt\n    ind_length = length ./ 1000\n    pred_length = ind_length ./ 0.01\n    pred_width = pred_length ./ 4\n    pred_image = 0.75 .* pred_length .* pred_width\n    rmax = ind_length .* 30\n    eye_sensitivity = (rmax.^2) ./ (pred_image .* pred_contrast)\n    surface_irradiance = ipar_curve(0)\n    I_z = surface_irradiance .* exp.(-attenuation_coefficient .* depth)\n    prey_size_factor = (min_prey+max_prey)/2\n    r = min.(1,ind_length .* sqrt.(I_z ./ (pred_contrast .* eye_sensitivity .* prey_size_factor)))\n    return r\nend",
    "crumbs": [
      "Model Components",
      "Behavioral Commands"
    ]
  },
  {
    "objectID": "components/behavior.html#behavioral-commands",
    "href": "components/behavior.html#behavioral-commands",
    "title": "SwimmingIndividuals.jl",
    "section": "",
    "text": "The behavior.jl file is the “brain” of the agents. It contains the functions that govern how agents perceive their environment and how they make decisions. This module is called for every living agent at each timestep and is the entry point for all subsequent actions like predation and movement.\n\n\nAn agent’s ability to see prey is not a fixed radius but is mechanistically determined by the physics of light in water. This system calculates the visual range for each agent in parallel on the GPU.\n\n\nThis is the launcher function that orchestrates the visual range calculation. It first determines the current surface light intensity using the ipar_curve helper function. It then prepares the necessary agent and trait data and calls the visual_range_kernel! to perform the calculation for all agents of a given species.\n# ===================================================================\n# GPU-Compliant Visual Range Calculation\n# ===================================================================\n\n# Kernel to calculate the visual range for prey for each agent in parallel.\n@kernel function visual_range_kernel!(vis_out, length, depth, min_prey, max_prey, surface_irradiance)\n    ind = @index(Global)\n\n    # Constants for light attenuation and visual acuity\n    pred_contrast = 0.3\n    salt = 30.0\n    attenuation_coefficient = 0.64 - 0.016 * salt\n    \n    # Agent-specific properties\n    ind_length_m = length[ind] / 1000.0\n    rmax = ind_length_m * 30.0\n    \n    # Simplified image size calculation for kernel\n    pred_image = 0.75 * (ind_length_m / 0.01) * (ind_length_m / 4.0)\n    eye_sensitivity = (rmax^2) / (pred_image * pred_contrast)\n    \n    # Calculate light intensity at the agent's current depth\n    I_z = surface_irradiance * exp(-attenuation_coefficient * depth[ind])\n    \n    prey_size_factor = (min_prey + max_prey) / 2.0\n    \n    # Final visual range calculation based on light, eye sensitivity, and prey size\n    r_sq = (I_z * ind_length_m^2) / (pred_contrast * eye_sensitivity * prey_size_factor)\n    r = r_sq &gt; 0 ? sqrt(r_sq) : 0.0\n    \n    @inbounds vis_out[ind] = clamp(r, 0.0, rmax)\nend\n\n# Launcher for the visual range kernel.\nfunction update_visual_range!(model::MarineModel, sp::Int)\n    arch = model.arch\n    data = model.individuals.animals[sp].data\n    p = model.individuals.animals[sp].p\n    \n    surface_irradiance = ipar_curve(model.t)\n    \n    kernel! = visual_range_kernel!(device(arch), 256, (length(data.x),))\n    kernel!(\n        data.vis_prey, data.length, data.z,\n        p.Min_Prey[2][sp], p.Max_Prey[2][sp],\n        surface_irradiance\n    )\n    KernelAbstractions.synchronize(device(arch))\nend\n\n\n\n\nThese functions represent the high-level decision-making process for the agents.\n\n\nThis is the main behavioral dispatcher. It first calls update_visual_range! for the current species. It then checks the species’ behavioral archetype (e.g., “dvm_strong”, “pelagic_diver”) and routes the agents to the appropriate specialized movement function (dvm_action! or dive_action!). Crucially, it then calls the decision function for any agents that are not currently engaged in a specialized, overriding behavior (like migrating).\n\n\n\nThis is the core foraging logic. For a given subset of agents, it calculates a “feed trigger” based on their gut fullness. It then uses a probabilistic check to determine which of these agents will attempt to forage during the current timestep. For those agents that decide to eat, it orchestrates the full predation sequence by calling calculate_distances_prey!, resolve_consumption!, and apply_consumption!. Finally, it calls movement_toward_habitat! for all agents in the subset, allowing them to use any time remaining in the timestep to move towards better habitat.\n# ===================================================================\n# Core Behavioral Functions\n# ===================================================================\n\n# Main behavioral dispatcher.\nfunction behavior(model::MarineModel, sp::Int, ind::Vector{Int}, outputs::MarineOutputs)\n    behave_type = model.individuals.animals[sp].p.Type[2][sp]\n    sp_dat = model.individuals.animals[sp].data\n    \n    # Update visual range for all agents of this species first\n    update_visual_range!(model, sp)\n\n    if behave_type == \"dvm_strong\"\n        dvm_action!(model, sp) # This kernel runs on all agents\n        \n        # Find which agents are NOT migrating to pass them to the decision function\n        mig_status_cpu = Array(sp_dat.mig_status)\n        not_migrating_indices = findall(x -&gt; x &lt;= 0.0, mig_status_cpu)\n        \n        # Intersect with the list of currently living agents\n        decision_inds = intersect(ind, not_migrating_indices)\n        \n        if !isempty(decision_inds)\n            decision(model, sp, decision_inds, outputs)\n        end\n\n    elseif behave_type == \"dvm_weak\"\n        dvm_action!(model, sp)\n        decision(model, sp, ind, outputs)\n\n    elseif behave_type == \"pelagic_diver\"\n        dive_action!(model, sp)\n        decision(model, sp, ind, outputs)\n        \n    elseif behave_type == \"non_mig\"\n        decision(model, sp, ind, outputs)\n    end\n    \n    return nothing\nend\n\n\n# Core decision-making function for foraging and movement.\nfunction decision(model::MarineModel, sp::Int, ind::Vector{Int64}, outputs::MarineOutputs)\n    sp_dat = model.individuals.animals[sp].data\n    arch = model.arch\n\n    # Create views to work with the subset of individuals\n    gut_fullness_view = @view sp_dat.gut_fullness[ind]\n    biomass_school_view = @view sp_dat.biomass_school[ind]\n\n    max_fullness = 0.2 .* biomass_school_view\n    feed_trigger = gut_fullness_view ./ max_fullness\n    \n    # Generate random numbers on the correct device\n    local val1\n    if arch isa GPU\n        val1 = CUDA.rand(Float32, length(ind))\n    else\n        val1 = rand(Float32, length(ind))\n    end\n\n    # Create a boolean mask on the GPU, copy it to CPU, then findall\n    eat_mask_gpu = (feed_trigger .&lt;= val1)\n    eat_mask_cpu = Array(eat_mask_gpu)\n    to_eat_indices = findall(eat_mask_cpu)\n\n    eating = ind[to_eat_indices]\n    \n    # Create the 'time' vector on the correct device\n    time = array_type(arch)(zeros(Float32, length(sp_dat.alive)))\n    time .= Float32(model.dt * 60.0)\n\n    if !isempty(eating)\n        # --- Predation Sequence ---\n        print(\"find prey | \")\n        calculate_distances_prey!(model, sp, eating)\n        \n        resolve_consumption!(model, sp, eating)\n        \n        print(\"eat | \")\n        apply_consumption!(model, sp, time,outputs)\n    end\n\n    print(\"move | \")\n    movement_toward_habitat!(model, sp, time)\n    \n    return nothing\nend\n\n\n\n\nThese are CPU-based versions of the visual range calculation that are used only once, during the model initialization, to set the starting visual range for newly created agents.\n# ===================================================================\n# CPU-based Initialization Functions (used only during setup)\n# ===================================================================\n\nfunction visual_range_preds_init(length,depth,min_pred,max_pred,ind)\n    pred_contrast = fill(0.3,ind)\n    salt = fill(30, ind)\n    attenuation_coefficient = 0.64 .- 0.016 .* salt\n    ind_length = length ./ 1000\n    pred_length = ind_length ./ 0.01\n    pred_width = pred_length ./ 4\n    pred_image = 0.75 .* pred_length .* pred_width\n    rmax = ind_length .* 30\n    eye_sensitivity = (rmax.^2) ./ (pred_image .* pred_contrast)\n    surface_irradiance = ipar_curve(0)\n    I_z = surface_irradiance .* exp.(-attenuation_coefficient .* depth)\n    pred_size_factor = 1+((min_pred+max_pred)/2)\n    r = max.(1,ind_length .* sqrt.(I_z ./ (pred_contrast .* eye_sensitivity .* pred_size_factor)))\n    return r\nend\n\nfunction visual_range_preys_init(length,depth,min_prey,max_prey,ind)\n    pred_contrast = fill(0.3,ind)\n    salt = fill(30, ind)\n    attenuation_coefficient = 0.64 .- 0.016 .* salt\n    ind_length = length ./ 1000\n    pred_length = ind_length ./ 0.01\n    pred_width = pred_length ./ 4\n    pred_image = 0.75 .* pred_length .* pred_width\n    rmax = ind_length .* 30\n    eye_sensitivity = (rmax.^2) ./ (pred_image .* pred_contrast)\n    surface_irradiance = ipar_curve(0)\n    I_z = surface_irradiance .* exp.(-attenuation_coefficient .* depth)\n    prey_size_factor = (min_prey+max_prey)/2\n    r = min.(1,ind_length .* sqrt.(I_z ./ (pred_contrast .* eye_sensitivity .* prey_size_factor)))\n    return r\nend",
    "crumbs": [
      "Model Components",
      "Behavioral Commands"
    ]
  },
  {
    "objectID": "components/create.html",
    "href": "components/create.html",
    "title": "SwimmingIndividuals.jl",
    "section": "",
    "text": "The create.jl file is responsible for creating all the agents and resources that populate the model world at the beginning of a simulation. It also contains the logic for how new agents are added to the population through reproduction during the simulation run.\n\n\nThis section contains the core functions for defining the data structure of a focal species agent and for populating the simulation with an initial set of these agents.\n\n\nThis function defines the “blueprint” for an agent. It creates a StructArray, which is a highly efficient data structure for storing large numbers of objects with the same fields. This is where every state variable for an agent (e.g., x, y, z, length, energy) is defined and pre-allocated in memory. This pre-allocation is a key performance optimization, especially for GPU execution.\n\n\n\nThis function populates the pre-allocated StructArray with the initial set of agents for a given species. It uses a “Gather, Compute, Update” pattern to be compatible with both CPU and GPU architectures. It first calculates the number of agents needed to meet a target biomass on the CPU. It then generates all the necessary state variables (e.g., size, position) in standard CPU arrays. Finally, it copies all this data to the target device (either CPU or GPU) in a single, efficient batch operation.\n\n\n\nThis is a high-level wrapper function that loops through each focal species defined in the model parameters, calling construct_individuals and initialize_individuals for each one to create the complete set of initial populations.\n# ===================================================================\n# Agent Creation and Initialization\n# ===================================================================\n\nfunction construct_individuals(arch::Architecture, params::Dict, maxN)\n    # Defines the full data structure for an agent, including all state variables\n    # and fields needed for spatial indexing and other calculations.\n    rawdata = StructArray(\n        x = zeros(Float64,maxN), y = zeros(Float64,maxN), z = zeros(Float64,maxN),\n        length = zeros(Float64,maxN), abundance = zeros(Float64,maxN),\n        biomass_ind = zeros(Float64,maxN), biomass_school = zeros(Float64,maxN),\n        energy = zeros(Float64,maxN), gut_fullness = zeros(Float64,maxN),\n        cost = zeros(Float64,maxN), pool_x = zeros(Int,maxN), pool_y = zeros(Int,maxN),\n        pool_z = zeros(Int,maxN), active = zeros(Float64,maxN),\n        ration = zeros(Float64,maxN), alive = zeros(Float64,maxN),\n        vis_prey = zeros(Float64,maxN), mature = zeros(Float64,maxN),\n        age=zeros(Float64,maxN),\n        cell_id = zeros(Int, maxN),\n        sorted_id = zeros(Int, maxN),\n        repro_energy = zeros(Float64, maxN),\n        best_prey_dist = zeros(Float32, maxN),\n        best_prey_idx = zeros(Int, maxN),\n        best_prey_sp = zeros(Int, maxN),\n        best_prey_type = zeros(Int, maxN),\n        successful_ration = zeros(Float64, maxN),\n        temp_idx = zeros(Int, maxN),\n        cell_starts = zeros(Int, maxN),\n        cell_ends = zeros(Int, maxN),\n        mig_status = zeros(Float64, maxN),\n        target_z = zeros(Float64, maxN),\n        interval = zeros(Float64, maxN),\n        dives_remaining = zeros(Int, maxN)\n    )\n\n    data = replace_storage(array_type(arch), rawdata)\n\n    param_names=(:Dive_Interval,:Min_Prey,:LWR_b, :Surface_Interval,:W_mat,:SpeciesLong, \n                 :LWR_a, :Larval_Size,:Max_Prey, :Max_Size, :Dive_Max,:School_Size,:Taxa,\n                 :Larval_Duration, :Sex_Ratio,:SpeciesShort,:FLR_b, :Dive_Min,:Handling_Time,\n                 :FLR_a,:Energy_density, :Hatch_Survival, :MR_type, :Swim_velo, :Biomass, :Type)\n\n    p = NamedTuple{param_names}(params)\n    return plankton(data, p)\nend\n\nfunction initialize_individuals(plank, B::Float64, sp::Int, depths::MarineDepths, capacities, dt, envi::MarineEnvironment)\n    # This function uses the \"Gather, Compute, Update\" pattern to be architecture-compliant.\n    \n    # --- 1. Pre-calculate constants and create temporary CPU arrays ---\n    grid = depths.grid\n    night_profs = depths.focal_night\n    depthres = grid[findfirst(grid.Name .== \"depthres\"), :Value]\n    maxdepth = grid[findfirst(grid.Name .== \"depthmax\"), :Value]\n    lonmax = grid[findfirst(grid.Name .== \"xulcorner\"), :Value]\n    lonmin = grid[findfirst(grid.Name .== \"xllcorner\"), :Value]\n    latmax = grid[findfirst(grid.Name .== \"yulcorner\"), :Value]\n    latmin = grid[findfirst(grid.Name .== \"yllcorner\"), :Value]\n    mean_lat_rad = deg2rad((latmin + latmax) / 2)\n    km_per_deg_lat = 111.32\n    km_per_deg_lon = 111.32 * cos(mean_lat_rad)\n    area_km2 = abs(latmax - latmin) * km_per_deg_lat * abs(lonmax - lonmin) * km_per_deg_lon\n    target_b = B * 1e6 * area_km2\n    school_size = plank.p.School_Size[2][sp]\n    max_size = plank.p.Max_Size[2][sp]\n\n    cpu_lengths, cpu_biomass_ind, cpu_biomass_school = Float64[], Float64[], Float64[]\n    \n    # --- 2. Generate core data on the CPU until target biomass is met ---\n    current_b = 0.0\n    μ, σ = lognormal_params_from_maxsize(max_size)\n    dist = LogNormal(μ, σ)\n    while current_b &lt; target_b\n        new_length = rand(dist)\n        while new_length &gt; max_size; new_length = rand(dist); end\n        ind_biomass = plank.p.LWR_a[2][sp] * (new_length / 10)^plank.p.LWR_b[2][sp]\n        school_biomass = ind_biomass * school_size\n        push!(cpu_lengths, new_length)\n        push!(cpu_biomass_ind, ind_biomass)\n        push!(cpu_biomass_school, school_biomass)\n        current_b += school_biomass\n    end\n\n    n_agents = length(cpu_lengths)\n\n    # --- 3. Generate remaining data in efficient, vectorized calls on the CPU ---\n    if n_agents &gt; 0\n        if n_agents &gt; length(plank.data.x)\n            @warn \"Generated $n_agents agents, but only have space for $(length(plank.data.x)). Truncating.\"\n            n_agents = length(plank.data.x)\n        end\n\n        cpu_abundance = fill(Float64(school_size), n_agents)\n        \n        land_mask = coalesce.(Array(envi.data[\"bathymetry\"]), 0.0) .&gt; 0\n        res = initial_ind_placement(Array(capacities), sp, grid, n_agents, 1, land_mask)\n        \n        cpu_x, cpu_y, cpu_pool_x, cpu_pool_y = res.lons, res.lats, res.grid_x, res.grid_y\n        cpu_z = gaussmix(n_agents, night_profs[sp, \"mu1\"], night_profs[sp, \"mu2\"], night_profs[sp, \"mu3\"], \n                                 night_profs[sp, \"sigma1\"], night_profs[sp, \"sigma2\"], night_profs[sp, \"sigma3\"], \n                                 night_profs[sp, \"lambda1\"], night_profs[sp, \"lambda2\"])\n        cpu_z = clamp.(cpu_z, 1.0, maxdepth)\n        cpu_pool_z = max.(1, ceil.(Int, cpu_z ./ (maxdepth / depthres)))\n        cpu_pool_z = clamp.(cpu_pool_z, 1, Int(depthres))\n        max_weight = plank.p.LWR_a[2][sp] * (max_size / 10)^plank.p.LWR_b[2][sp]\n        cpu_mature = min.(1.0, cpu_biomass_ind ./ (plank.p.W_mat[2][sp] * max_weight))\n        cpu_vis_prey = visual_range_preys_init(cpu_lengths, cpu_z, plank.p.Min_Prey[2][sp], plank.p.Max_Prey[2][sp], n_agents) .* dt\n        remaining_dives = 1440/(plank.p.Surface_Interval[2][sp] + plank.p.Dive_Interval[2][sp])\n        \n        # --- 4. Copy all data from CPU arrays to the target device (CPU or GPU) in one batch ---\n        copyto!(plank.data.length, 1, cpu_lengths, 1, n_agents)\n        copyto!(plank.data.biomass_ind, 1, cpu_biomass_ind, 1, n_agents)\n        copyto!(plank.data.biomass_school, 1, cpu_biomass_school, 1, n_agents)\n        copyto!(plank.data.abundance, 1, cpu_abundance, 1, n_agents)\n        copyto!(plank.data.x, 1, cpu_x, 1, n_agents)\n        copyto!(plank.data.y, 1, cpu_y, 1, n_agents)\n        copyto!(plank.data.z, 1, cpu_z, 1, n_agents)\n        copyto!(plank.data.pool_x, 1, cpu_pool_x, 1, n_agents)\n        copyto!(plank.data.pool_y, 1, cpu_pool_y, 1, n_agents)\n        copyto!(plank.data.pool_z, 1, cpu_pool_z, 1, n_agents)\n        copyto!(plank.data.mature, 1, cpu_mature, 1, n_agents)\n        copyto!(plank.data.vis_prey, 1, cpu_vis_prey, 1, n_agents)\n        # Initialize other fields\n        @views plank.data.alive[1:n_agents] .= 1.0\n        @views plank.data.energy[1:n_agents] .= plank.data.biomass_school[1:n_agents] .* plank.p.Energy_density[2][sp] .* 0.2\n        @views plank.data.gut_fullness[1:n_agents] .= 0.2\n        @views plank.data.age[1:n_agents] .= plank.p.Larval_Duration[2][sp]\n        @views plank.data.dives_remaining[1:n_agents] .= remaining_dives\n        \n        # Set remaining unused slots to non-alive\n        @views plank.data.alive[n_agents+1:end] .= 0.0\n    end\n    return plank.data\nend\n\nfunction generate_individuals(params::Dict, arch::Architecture, Nsp::Int, B, maxN::Int, depths::MarineDepths, capacities, dt, envi::MarineEnvironment)\n    plank_names = Symbol[]\n    plank_data=[]\n    for i in 1:Nsp\n        name = Symbol(\"sp\"*string(i))\n        plank = construct_individuals(arch, params, maxN)\n        initialize_individuals(plank, B[i], i, depths, capacities, dt, envi)\n        push!(plank_names, name)\n        push!(plank_data, plank)\n    end\n    planks = NamedTuple{Tuple(plank_names)}(plank_data)\n    return individuals(planks)\nend\n\n\n\n\nThis section contains the functions for initializing the resource grids and for updating them through logistic growth.\n\n\nThis function is responsible for creating the initial state of the resource grids. It allocates two 4D arrays (biomass and capacity) on the target device (CPU or GPU). It then calls a high-performance GPU kernel (initialize_resources_kernel!) that runs in parallel for every grid cell. The kernel calculates the initial biomass density for each resource species in each cell based on the habitat capacity maps and the species’ vertical distribution profile.\n\n\n\nThis function is called at each timestep to update the resource biomass. It launches a GPU kernel (resource_growth_kernel!) that applies a logistic growth equation to every cell in the resource grid, allowing the resource populations to grow towards their carrying capacity.\n# ===================================================================\n# Resource Creation and Dynamics\n# ===================================================================\n\n@kernel function initialize_resources_kernel!(\n    resource_biomass, resource_capacity, capacities, traits_gpu, \n    n_spec, max_depth, depth_res_m\n)\n    lon, lat, depth_idx = @index(Global, NTuple)\n\n    for res_sp in 1:size(resource_biomass, 4)\n        avg_capacity = 0.0\n        for month in 1:size(capacities, 3)\n            avg_capacity += capacities[lon, lat, month, res_sp + n_spec]\n        end\n        avg_capacity /= size(capacities, 3)\n        \n        if avg_capacity &gt; 0\n            depth_m = (depth_idx - 1) * depth_res_m\n            depth_pref = exp(-0.005 * depth_m)\n            density = traits_gpu.Biomass[res_sp] * 1_000_000\n            biomass = density * avg_capacity * depth_pref\n            \n            resource_biomass[lon, lat, depth_idx, res_sp] = biomass\n            resource_capacity[lon, lat, depth_idx, res_sp] = biomass\n        end\n    end\nend\n\nfunction initialize_resources(\n    traits::DataFrame, n_spec::Int, n_resource::Int, \n    depths::MarineDepths, capacities::AbstractArray, arch::Architecture\n)\n    grid = depths.grid\n    depthres = Int(grid[grid.Name .== \"depthres\", :Value][1])\n    latres = Int(grid[grid.Name .== \"latres\", :Value][1])\n    lonres = Int(grid[grid.Name .== \"lonres\", :Value][1])\n    \n    resource_biomass = array_type(arch)(zeros(Float64, lonres, latres, depthres, n_resource))\n    resource_capacity = array_type(arch)(zeros(Float64, lonres, latres, depthres, n_resource))\n    \n    traits_gpu = (; (Symbol(c) =&gt; array_type(arch)(traits[:, c]) for c in names(traits))...)\n    max_depth = Int(grid[grid.Name .== \"depthmax\", :Value][1])\n    depth_res_m = max_depth / depthres\n\n    kernel! = initialize_resources_kernel!(device(arch), (8, 8, 4), (lonres, latres, depthres))\n    kernel!(\n        resource_biomass, \n        resource_capacity, \n        capacities, \n        traits_gpu, \n        n_spec, \n        max_depth, \n        depth_res_m\n    )\n    \n    KernelAbstractions.synchronize(device(arch))\n    return (biomass = resource_biomass, capacity = resource_capacity)\nend\n\n# Kernel for resource growth\n@kernel function resource_growth_kernel!(biomass_grid, capacity_grid, resource_trait)\n    lon, lat, depth, sp = @index(Global, NTuple)\n    biomass = biomass_grid[lon, lat, depth, sp]\n    capacity = capacity_grid[lon, lat, depth, sp]\n    if biomass &gt; 0 && capacity &gt; 0\n        rate = resource_trait.Growth[sp]\n        @inbounds biomass_grid[lon, lat, depth, sp] = biomass + rate * biomass * (1.0 - biomass / capacity)\n    end\nend\n\n# Launcher for resource growth\nfunction resource_growth!(model::MarineModel)\n    arch = model.arch\n    trait_gpu = (; (Symbol(c) =&gt; array_type(arch)(model.resource_trait[:, c]) for c in names(model.resource_trait))...)\n    kernel! = resource_growth_kernel!(device(arch), (8, 8, 4, 1), size(model.resources.biomass))\n    kernel!(model.resources.biomass, model.resources.capacity, trait_gpu)\n    KernelAbstractions.synchronize(device(arch))\nend\n\n\n\n\nThis system handles the creation of new agents during the simulation run. It uses the “Gather, Compute, Update” pattern to remain architecture-compliant.\n\n\nThis is the main launcher function for the reproduction process. It is called from the energy! function. It first gathers all the necessary data for reproducing agents from the GPU to the CPU. It then calls calculate_new_offspring_cpu to determine the properties of the new agents. Finally, it finds empty slots in the main agent StructArray and copies the data for the new offspring into these slots, effectively adding them to the simulation.\n# ===================================================================\n# Reproduction System\n# ===================================================================\n\n# CPU-only function to calculate new offspring properties\nfunction calculate_new_offspring_cpu(p_cpu, parent_data, repro_energy_list, spawn_val, sp)\n    egg_volume = 0.15 .* parent_data.biomass_ind .^ 0.14\n    egg_energy = 2.15 .* egg_volume .^ 0.77\n    spent_energy = repro_energy_list .* spawn_val .* 0.9\n    num_eggs_per_parent = floor.(Int, spent_energy ./ egg_energy .* p_cpu.Sex_Ratio.second[sp] .* p_cpu.Hatch_Survival.second[sp])\n\n    total_eggs = sum(num_eggs_per_parent)\n    if total_eggs == 0; return nothing; end\n\n    new_x, new_y, new_z = zeros(total_eggs), zeros(total_eggs), zeros(total_eggs)\n    new_pool_x, new_pool_y, new_pool_z = zeros(Int, total_eggs), zeros(Int, total_eggs), zeros(Int, total_eggs)\n    new_length = zeros(total_eggs)\n    \n    current_idx = 1\n    for i in 1:length(parent_data.x)\n        num_eggs = num_eggs_per_parent[i]\n        if num_eggs &gt; 0\n            indices = current_idx:(current_idx + num_eggs - 1)\n            new_x[indices] .= parent_data.x[i]\n            new_y[indices] .= parent_data.y[i]\n            new_z[indices] .= parent_data.z[i]\n            new_pool_x[indices] .= parent_data.pool_x[i]\n            new_pool_y[indices] .= parent_data.pool_y[i]\n            new_pool_z[indices] .= parent_data.pool_z[i]\n            rand_lengths = rand(Float32, num_eggs) .* p_cpu.Larval_Size.second[sp]\n            new_length[indices] .= rand_lengths\n            current_idx += num_eggs\n        end\n    end\n\n    new_biomass_ind = p_cpu.LWR_a.second[sp] .* (new_length ./ 10.0) .^ p_cpu.LWR_b.second[sp]\n    \n    return (\n        x=new_x, y=new_y, z=new_z, length=new_length,\n        abundance=fill(Float64(p_cpu.School_Size.second[sp]), total_eggs),\n        biomass_ind=new_biomass_ind,\n        biomass_school=new_biomass_ind .* p_cpu.School_Size.second[sp],\n        energy = new_biomass_ind .* p_cpu.School_Size.second[sp] .* p_cpu.Energy_density.second[sp] .* 0.2,\n        gut_fullness = fill(0.2, total_eggs),\n        age = zeros(total_eggs),\n        pool_x=new_pool_x, pool_y=new_pool_y, pool_z=new_pool_z\n    )\nend\n\n# Manages the GPU/CPU data transfer for reproduction\nfunction process_reproduction!(model::MarineModel, sp::Int, spawn_val::Real)\n    arch = model.arch\n    data = model.individuals.animals[sp].data\n    p_cpu = model.individuals.animals[sp].p\n\n    repro_energy_all = Array(data.repro_energy)\n    repro_inds = findall(repro_energy_all .&gt; 0)\n    if isempty(repro_inds); return; end\n\n    parent_data_cpu = (\n        x = Array(data.x[repro_inds]), y = Array(data.y[repro_inds]), z = Array(data.z[repro_inds]),\n        pool_x = Array(data.pool_x[repro_inds]), pool_y = Array(data.pool_y[repro_inds]), pool_z = Array(data.pool_z[repro_inds]),\n        biomass_ind = Array(data.biomass_ind[repro_inds])\n    )\n\n    new_offspring = calculate_new_offspring_cpu(p_cpu, parent_data_cpu, repro_energy_all[repro_inds], spawn_val, sp)\n    if new_offspring === nothing; return; end\n    \n    num_new = length(new_offspring.x)\n    if num_new == 0; return; end\n\n    dead_slots = findall(Array(data.alive) .== 0)\n    num_to_add = min(num_new, length(dead_slots))\n    if num_to_add &lt; num_new\n        @warn \"Not enough space for all new offspring. Discarding $(num_new - num_to_add) individuals.\"\n    end\n\n    if num_to_add &gt; 0\n        slots_to_fill = @view dead_slots[1:num_to_add]\n        for (field, values) in pairs(new_offspring)\n            dest_view = @view getproperty(data, field)[slots_to_fill]\n            source_view = @view values[1:num_to_add]\n            copyto!(dest_view, source_view)\n        end\n        @view(data.alive[slots_to_fill]) .= 1.0\n    end\n    @view(data.repro_energy[repro_inds]) .= 0.0\nend",
    "crumbs": [
      "Model Components",
      "Individual Creation & Reproduction"
    ]
  },
  {
    "objectID": "components/create.html#individual-creation-reproduction",
    "href": "components/create.html#individual-creation-reproduction",
    "title": "SwimmingIndividuals.jl",
    "section": "",
    "text": "The create.jl file is responsible for creating all the agents and resources that populate the model world at the beginning of a simulation. It also contains the logic for how new agents are added to the population through reproduction during the simulation run.\n\n\nThis section contains the core functions for defining the data structure of a focal species agent and for populating the simulation with an initial set of these agents.\n\n\nThis function defines the “blueprint” for an agent. It creates a StructArray, which is a highly efficient data structure for storing large numbers of objects with the same fields. This is where every state variable for an agent (e.g., x, y, z, length, energy) is defined and pre-allocated in memory. This pre-allocation is a key performance optimization, especially for GPU execution.\n\n\n\nThis function populates the pre-allocated StructArray with the initial set of agents for a given species. It uses a “Gather, Compute, Update” pattern to be compatible with both CPU and GPU architectures. It first calculates the number of agents needed to meet a target biomass on the CPU. It then generates all the necessary state variables (e.g., size, position) in standard CPU arrays. Finally, it copies all this data to the target device (either CPU or GPU) in a single, efficient batch operation.\n\n\n\nThis is a high-level wrapper function that loops through each focal species defined in the model parameters, calling construct_individuals and initialize_individuals for each one to create the complete set of initial populations.\n# ===================================================================\n# Agent Creation and Initialization\n# ===================================================================\n\nfunction construct_individuals(arch::Architecture, params::Dict, maxN)\n    # Defines the full data structure for an agent, including all state variables\n    # and fields needed for spatial indexing and other calculations.\n    rawdata = StructArray(\n        x = zeros(Float64,maxN), y = zeros(Float64,maxN), z = zeros(Float64,maxN),\n        length = zeros(Float64,maxN), abundance = zeros(Float64,maxN),\n        biomass_ind = zeros(Float64,maxN), biomass_school = zeros(Float64,maxN),\n        energy = zeros(Float64,maxN), gut_fullness = zeros(Float64,maxN),\n        cost = zeros(Float64,maxN), pool_x = zeros(Int,maxN), pool_y = zeros(Int,maxN),\n        pool_z = zeros(Int,maxN), active = zeros(Float64,maxN),\n        ration = zeros(Float64,maxN), alive = zeros(Float64,maxN),\n        vis_prey = zeros(Float64,maxN), mature = zeros(Float64,maxN),\n        age=zeros(Float64,maxN),\n        cell_id = zeros(Int, maxN),\n        sorted_id = zeros(Int, maxN),\n        repro_energy = zeros(Float64, maxN),\n        best_prey_dist = zeros(Float32, maxN),\n        best_prey_idx = zeros(Int, maxN),\n        best_prey_sp = zeros(Int, maxN),\n        best_prey_type = zeros(Int, maxN),\n        successful_ration = zeros(Float64, maxN),\n        temp_idx = zeros(Int, maxN),\n        cell_starts = zeros(Int, maxN),\n        cell_ends = zeros(Int, maxN),\n        mig_status = zeros(Float64, maxN),\n        target_z = zeros(Float64, maxN),\n        interval = zeros(Float64, maxN),\n        dives_remaining = zeros(Int, maxN)\n    )\n\n    data = replace_storage(array_type(arch), rawdata)\n\n    param_names=(:Dive_Interval,:Min_Prey,:LWR_b, :Surface_Interval,:W_mat,:SpeciesLong, \n                 :LWR_a, :Larval_Size,:Max_Prey, :Max_Size, :Dive_Max,:School_Size,:Taxa,\n                 :Larval_Duration, :Sex_Ratio,:SpeciesShort,:FLR_b, :Dive_Min,:Handling_Time,\n                 :FLR_a,:Energy_density, :Hatch_Survival, :MR_type, :Swim_velo, :Biomass, :Type)\n\n    p = NamedTuple{param_names}(params)\n    return plankton(data, p)\nend\n\nfunction initialize_individuals(plank, B::Float64, sp::Int, depths::MarineDepths, capacities, dt, envi::MarineEnvironment)\n    # This function uses the \"Gather, Compute, Update\" pattern to be architecture-compliant.\n    \n    # --- 1. Pre-calculate constants and create temporary CPU arrays ---\n    grid = depths.grid\n    night_profs = depths.focal_night\n    depthres = grid[findfirst(grid.Name .== \"depthres\"), :Value]\n    maxdepth = grid[findfirst(grid.Name .== \"depthmax\"), :Value]\n    lonmax = grid[findfirst(grid.Name .== \"xulcorner\"), :Value]\n    lonmin = grid[findfirst(grid.Name .== \"xllcorner\"), :Value]\n    latmax = grid[findfirst(grid.Name .== \"yulcorner\"), :Value]\n    latmin = grid[findfirst(grid.Name .== \"yllcorner\"), :Value]\n    mean_lat_rad = deg2rad((latmin + latmax) / 2)\n    km_per_deg_lat = 111.32\n    km_per_deg_lon = 111.32 * cos(mean_lat_rad)\n    area_km2 = abs(latmax - latmin) * km_per_deg_lat * abs(lonmax - lonmin) * km_per_deg_lon\n    target_b = B * 1e6 * area_km2\n    school_size = plank.p.School_Size[2][sp]\n    max_size = plank.p.Max_Size[2][sp]\n\n    cpu_lengths, cpu_biomass_ind, cpu_biomass_school = Float64[], Float64[], Float64[]\n    \n    # --- 2. Generate core data on the CPU until target biomass is met ---\n    current_b = 0.0\n    μ, σ = lognormal_params_from_maxsize(max_size)\n    dist = LogNormal(μ, σ)\n    while current_b &lt; target_b\n        new_length = rand(dist)\n        while new_length &gt; max_size; new_length = rand(dist); end\n        ind_biomass = plank.p.LWR_a[2][sp] * (new_length / 10)^plank.p.LWR_b[2][sp]\n        school_biomass = ind_biomass * school_size\n        push!(cpu_lengths, new_length)\n        push!(cpu_biomass_ind, ind_biomass)\n        push!(cpu_biomass_school, school_biomass)\n        current_b += school_biomass\n    end\n\n    n_agents = length(cpu_lengths)\n\n    # --- 3. Generate remaining data in efficient, vectorized calls on the CPU ---\n    if n_agents &gt; 0\n        if n_agents &gt; length(plank.data.x)\n            @warn \"Generated $n_agents agents, but only have space for $(length(plank.data.x)). Truncating.\"\n            n_agents = length(plank.data.x)\n        end\n\n        cpu_abundance = fill(Float64(school_size), n_agents)\n        \n        land_mask = coalesce.(Array(envi.data[\"bathymetry\"]), 0.0) .&gt; 0\n        res = initial_ind_placement(Array(capacities), sp, grid, n_agents, 1, land_mask)\n        \n        cpu_x, cpu_y, cpu_pool_x, cpu_pool_y = res.lons, res.lats, res.grid_x, res.grid_y\n        cpu_z = gaussmix(n_agents, night_profs[sp, \"mu1\"], night_profs[sp, \"mu2\"], night_profs[sp, \"mu3\"], \n                                 night_profs[sp, \"sigma1\"], night_profs[sp, \"sigma2\"], night_profs[sp, \"sigma3\"], \n                                 night_profs[sp, \"lambda1\"], night_profs[sp, \"lambda2\"])\n        cpu_z = clamp.(cpu_z, 1.0, maxdepth)\n        cpu_pool_z = max.(1, ceil.(Int, cpu_z ./ (maxdepth / depthres)))\n        cpu_pool_z = clamp.(cpu_pool_z, 1, Int(depthres))\n        max_weight = plank.p.LWR_a[2][sp] * (max_size / 10)^plank.p.LWR_b[2][sp]\n        cpu_mature = min.(1.0, cpu_biomass_ind ./ (plank.p.W_mat[2][sp] * max_weight))\n        cpu_vis_prey = visual_range_preys_init(cpu_lengths, cpu_z, plank.p.Min_Prey[2][sp], plank.p.Max_Prey[2][sp], n_agents) .* dt\n        remaining_dives = 1440/(plank.p.Surface_Interval[2][sp] + plank.p.Dive_Interval[2][sp])\n        \n        # --- 4. Copy all data from CPU arrays to the target device (CPU or GPU) in one batch ---\n        copyto!(plank.data.length, 1, cpu_lengths, 1, n_agents)\n        copyto!(plank.data.biomass_ind, 1, cpu_biomass_ind, 1, n_agents)\n        copyto!(plank.data.biomass_school, 1, cpu_biomass_school, 1, n_agents)\n        copyto!(plank.data.abundance, 1, cpu_abundance, 1, n_agents)\n        copyto!(plank.data.x, 1, cpu_x, 1, n_agents)\n        copyto!(plank.data.y, 1, cpu_y, 1, n_agents)\n        copyto!(plank.data.z, 1, cpu_z, 1, n_agents)\n        copyto!(plank.data.pool_x, 1, cpu_pool_x, 1, n_agents)\n        copyto!(plank.data.pool_y, 1, cpu_pool_y, 1, n_agents)\n        copyto!(plank.data.pool_z, 1, cpu_pool_z, 1, n_agents)\n        copyto!(plank.data.mature, 1, cpu_mature, 1, n_agents)\n        copyto!(plank.data.vis_prey, 1, cpu_vis_prey, 1, n_agents)\n        # Initialize other fields\n        @views plank.data.alive[1:n_agents] .= 1.0\n        @views plank.data.energy[1:n_agents] .= plank.data.biomass_school[1:n_agents] .* plank.p.Energy_density[2][sp] .* 0.2\n        @views plank.data.gut_fullness[1:n_agents] .= 0.2\n        @views plank.data.age[1:n_agents] .= plank.p.Larval_Duration[2][sp]\n        @views plank.data.dives_remaining[1:n_agents] .= remaining_dives\n        \n        # Set remaining unused slots to non-alive\n        @views plank.data.alive[n_agents+1:end] .= 0.0\n    end\n    return plank.data\nend\n\nfunction generate_individuals(params::Dict, arch::Architecture, Nsp::Int, B, maxN::Int, depths::MarineDepths, capacities, dt, envi::MarineEnvironment)\n    plank_names = Symbol[]\n    plank_data=[]\n    for i in 1:Nsp\n        name = Symbol(\"sp\"*string(i))\n        plank = construct_individuals(arch, params, maxN)\n        initialize_individuals(plank, B[i], i, depths, capacities, dt, envi)\n        push!(plank_names, name)\n        push!(plank_data, plank)\n    end\n    planks = NamedTuple{Tuple(plank_names)}(plank_data)\n    return individuals(planks)\nend\n\n\n\n\nThis section contains the functions for initializing the resource grids and for updating them through logistic growth.\n\n\nThis function is responsible for creating the initial state of the resource grids. It allocates two 4D arrays (biomass and capacity) on the target device (CPU or GPU). It then calls a high-performance GPU kernel (initialize_resources_kernel!) that runs in parallel for every grid cell. The kernel calculates the initial biomass density for each resource species in each cell based on the habitat capacity maps and the species’ vertical distribution profile.\n\n\n\nThis function is called at each timestep to update the resource biomass. It launches a GPU kernel (resource_growth_kernel!) that applies a logistic growth equation to every cell in the resource grid, allowing the resource populations to grow towards their carrying capacity.\n# ===================================================================\n# Resource Creation and Dynamics\n# ===================================================================\n\n@kernel function initialize_resources_kernel!(\n    resource_biomass, resource_capacity, capacities, traits_gpu, \n    n_spec, max_depth, depth_res_m\n)\n    lon, lat, depth_idx = @index(Global, NTuple)\n\n    for res_sp in 1:size(resource_biomass, 4)\n        avg_capacity = 0.0\n        for month in 1:size(capacities, 3)\n            avg_capacity += capacities[lon, lat, month, res_sp + n_spec]\n        end\n        avg_capacity /= size(capacities, 3)\n        \n        if avg_capacity &gt; 0\n            depth_m = (depth_idx - 1) * depth_res_m\n            depth_pref = exp(-0.005 * depth_m)\n            density = traits_gpu.Biomass[res_sp] * 1_000_000\n            biomass = density * avg_capacity * depth_pref\n            \n            resource_biomass[lon, lat, depth_idx, res_sp] = biomass\n            resource_capacity[lon, lat, depth_idx, res_sp] = biomass\n        end\n    end\nend\n\nfunction initialize_resources(\n    traits::DataFrame, n_spec::Int, n_resource::Int, \n    depths::MarineDepths, capacities::AbstractArray, arch::Architecture\n)\n    grid = depths.grid\n    depthres = Int(grid[grid.Name .== \"depthres\", :Value][1])\n    latres = Int(grid[grid.Name .== \"latres\", :Value][1])\n    lonres = Int(grid[grid.Name .== \"lonres\", :Value][1])\n    \n    resource_biomass = array_type(arch)(zeros(Float64, lonres, latres, depthres, n_resource))\n    resource_capacity = array_type(arch)(zeros(Float64, lonres, latres, depthres, n_resource))\n    \n    traits_gpu = (; (Symbol(c) =&gt; array_type(arch)(traits[:, c]) for c in names(traits))...)\n    max_depth = Int(grid[grid.Name .== \"depthmax\", :Value][1])\n    depth_res_m = max_depth / depthres\n\n    kernel! = initialize_resources_kernel!(device(arch), (8, 8, 4), (lonres, latres, depthres))\n    kernel!(\n        resource_biomass, \n        resource_capacity, \n        capacities, \n        traits_gpu, \n        n_spec, \n        max_depth, \n        depth_res_m\n    )\n    \n    KernelAbstractions.synchronize(device(arch))\n    return (biomass = resource_biomass, capacity = resource_capacity)\nend\n\n# Kernel for resource growth\n@kernel function resource_growth_kernel!(biomass_grid, capacity_grid, resource_trait)\n    lon, lat, depth, sp = @index(Global, NTuple)\n    biomass = biomass_grid[lon, lat, depth, sp]\n    capacity = capacity_grid[lon, lat, depth, sp]\n    if biomass &gt; 0 && capacity &gt; 0\n        rate = resource_trait.Growth[sp]\n        @inbounds biomass_grid[lon, lat, depth, sp] = biomass + rate * biomass * (1.0 - biomass / capacity)\n    end\nend\n\n# Launcher for resource growth\nfunction resource_growth!(model::MarineModel)\n    arch = model.arch\n    trait_gpu = (; (Symbol(c) =&gt; array_type(arch)(model.resource_trait[:, c]) for c in names(model.resource_trait))...)\n    kernel! = resource_growth_kernel!(device(arch), (8, 8, 4, 1), size(model.resources.biomass))\n    kernel!(model.resources.biomass, model.resources.capacity, trait_gpu)\n    KernelAbstractions.synchronize(device(arch))\nend\n\n\n\n\nThis system handles the creation of new agents during the simulation run. It uses the “Gather, Compute, Update” pattern to remain architecture-compliant.\n\n\nThis is the main launcher function for the reproduction process. It is called from the energy! function. It first gathers all the necessary data for reproducing agents from the GPU to the CPU. It then calls calculate_new_offspring_cpu to determine the properties of the new agents. Finally, it finds empty slots in the main agent StructArray and copies the data for the new offspring into these slots, effectively adding them to the simulation.\n# ===================================================================\n# Reproduction System\n# ===================================================================\n\n# CPU-only function to calculate new offspring properties\nfunction calculate_new_offspring_cpu(p_cpu, parent_data, repro_energy_list, spawn_val, sp)\n    egg_volume = 0.15 .* parent_data.biomass_ind .^ 0.14\n    egg_energy = 2.15 .* egg_volume .^ 0.77\n    spent_energy = repro_energy_list .* spawn_val .* 0.9\n    num_eggs_per_parent = floor.(Int, spent_energy ./ egg_energy .* p_cpu.Sex_Ratio.second[sp] .* p_cpu.Hatch_Survival.second[sp])\n\n    total_eggs = sum(num_eggs_per_parent)\n    if total_eggs == 0; return nothing; end\n\n    new_x, new_y, new_z = zeros(total_eggs), zeros(total_eggs), zeros(total_eggs)\n    new_pool_x, new_pool_y, new_pool_z = zeros(Int, total_eggs), zeros(Int, total_eggs), zeros(Int, total_eggs)\n    new_length = zeros(total_eggs)\n    \n    current_idx = 1\n    for i in 1:length(parent_data.x)\n        num_eggs = num_eggs_per_parent[i]\n        if num_eggs &gt; 0\n            indices = current_idx:(current_idx + num_eggs - 1)\n            new_x[indices] .= parent_data.x[i]\n            new_y[indices] .= parent_data.y[i]\n            new_z[indices] .= parent_data.z[i]\n            new_pool_x[indices] .= parent_data.pool_x[i]\n            new_pool_y[indices] .= parent_data.pool_y[i]\n            new_pool_z[indices] .= parent_data.pool_z[i]\n            rand_lengths = rand(Float32, num_eggs) .* p_cpu.Larval_Size.second[sp]\n            new_length[indices] .= rand_lengths\n            current_idx += num_eggs\n        end\n    end\n\n    new_biomass_ind = p_cpu.LWR_a.second[sp] .* (new_length ./ 10.0) .^ p_cpu.LWR_b.second[sp]\n    \n    return (\n        x=new_x, y=new_y, z=new_z, length=new_length,\n        abundance=fill(Float64(p_cpu.School_Size.second[sp]), total_eggs),\n        biomass_ind=new_biomass_ind,\n        biomass_school=new_biomass_ind .* p_cpu.School_Size.second[sp],\n        energy = new_biomass_ind .* p_cpu.School_Size.second[sp] .* p_cpu.Energy_density.second[sp] .* 0.2,\n        gut_fullness = fill(0.2, total_eggs),\n        age = zeros(total_eggs),\n        pool_x=new_pool_x, pool_y=new_pool_y, pool_z=new_pool_z\n    )\nend\n\n# Manages the GPU/CPU data transfer for reproduction\nfunction process_reproduction!(model::MarineModel, sp::Int, spawn_val::Real)\n    arch = model.arch\n    data = model.individuals.animals[sp].data\n    p_cpu = model.individuals.animals[sp].p\n\n    repro_energy_all = Array(data.repro_energy)\n    repro_inds = findall(repro_energy_all .&gt; 0)\n    if isempty(repro_inds); return; end\n\n    parent_data_cpu = (\n        x = Array(data.x[repro_inds]), y = Array(data.y[repro_inds]), z = Array(data.z[repro_inds]),\n        pool_x = Array(data.pool_x[repro_inds]), pool_y = Array(data.pool_y[repro_inds]), pool_z = Array(data.pool_z[repro_inds]),\n        biomass_ind = Array(data.biomass_ind[repro_inds])\n    )\n\n    new_offspring = calculate_new_offspring_cpu(p_cpu, parent_data_cpu, repro_energy_all[repro_inds], spawn_val, sp)\n    if new_offspring === nothing; return; end\n    \n    num_new = length(new_offspring.x)\n    if num_new == 0; return; end\n\n    dead_slots = findall(Array(data.alive) .== 0)\n    num_to_add = min(num_new, length(dead_slots))\n    if num_to_add &lt; num_new\n        @warn \"Not enough space for all new offspring. Discarding $(num_new - num_to_add) individuals.\"\n    end\n\n    if num_to_add &gt; 0\n        slots_to_fill = @view dead_slots[1:num_to_add]\n        for (field, values) in pairs(new_offspring)\n            dest_view = @view getproperty(data, field)[slots_to_fill]\n            source_view = @view values[1:num_to_add]\n            copyto!(dest_view, source_view)\n        end\n        @view(data.alive[slots_to_fill]) .= 1.0\n    end\n    @view(data.repro_energy[repro_inds]) .= 0.0\nend",
    "crumbs": [
      "Model Components",
      "Individual Creation & Reproduction"
    ]
  },
  {
    "objectID": "components/environment.html",
    "href": "components/environment.html",
    "title": "SwimmingIndividuals.jl",
    "section": "",
    "text": "The environment.jl file is the cornerstone of the model’s physical world. It contains the functions responsible for loading environmental data from external files, calculating habitat suitability for each species, placing agents into the world, and allowing agents to sense their local conditions.\n\n\nThe simulation begins by loading all necessary environmental data grids from a single NetCDF file (environment.nc).\n\n\nThis is the primary function for setting up the model’s environment. It reads the specified NetCDF file, loads each variable (e.g., temp, salinity, bathymetry) into memory, and moves the data to the appropriate computational architecture (CPU or GPU). As a diagnostic step, it also generates and saves a plot of the surface layer for each variable to help the user verify that the data has been loaded correctly.\n# ===================================================================\n# Data Structures and Environment Loading\n# ===================================================================\n\nfunction generate_environment!(arch::Architecture, nc_file::String,plt_diags)\n    ds = NCDataset(nc_file)\n    envi_data = Dict{String, AbstractArray}()\n    output_dir = \"./results/Test/Environment\"\n    mkpath(output_dir)\n    @info \"Saving environment plots to: $output_dir\"\n\n    for var_name in keys(ds)\n        if var_name in [\"lon\", \"lat\", \"depth\", \"time\"]\n            continue\n        end\n        \n        @info \"Loading and plotting environmental variable: $var_name\"\n        \n        data_cpu = ds[var_name]\n        envi_data[var_name] = array_type(arch)(data_cpu)\n\n        # Plotting logic\n        if plt_diags == 1\n            local surface_slice\n            if ndims(data_cpu) &gt;= 3\n                if ndims(data_cpu) == 4\n                    surface_slice = data_cpu[:, :, 1, 1]\n                else # 3D\n                    surface_slice = data_cpu[:, :, 1]\n                end\n            elseif ndims(data_cpu) == 2\n                surface_slice = data_cpu\n            else\n                @warn \"Skipping plot for variable '$var_name' with unsupported dimensions.\"\n                continue\n            end\n\n            p = heatmap(\n                surface_slice',\n                title = \"Surface Layer: $var_name (Month 1)\",\n                xlabel = \"Longitude Index\",\n                ylabel = \"Latitude Index\",\n                c = :viridis\n            )\n            savefig(p, joinpath(output_dir, \"$(var_name)_surface.png\"))\n        end\n    end\n\n    close(ds)\n    return MarineEnvironment(envi_data, 1)\nend\n\n\n\n\nThis system allows each agent to determine the ambient water temperature at its specific location in the 3D grid. It uses a high-performance, two-kernel “Index-Gather” pattern to do this efficiently on the GPU.\n\n\nThis is the main launcher function. It first calls calculate_temp_indices_kernel! to have each agent determine its linear index into the 4D temperature grid. It then calls gather_temps_kernel! to perform a highly efficient lookup using these pre-calculated indices.\n# ===================================================================\n# Agent Temperature Sensing System\n# ===================================================================\n\n@kernel function calculate_temp_indices_kernel!(\n    temp_idx_out, alive, pool_x, pool_y, pool_z,\n    envi_ts, lonres, latres, depthres\n)\n    ind = @index(Global)\n    @inbounds if alive[ind] == 1.0\n        x, y, z = pool_x[ind], pool_y[ind], pool_z[ind]\n        if 1 &lt;= x &lt;= lonres && 1 &lt;= y &lt;= latres && 1 &lt;= z &lt;= depthres\n            linear_idx = x + (y-1)*lonres + (z-1)*lonres*latres + (envi_ts-1)*lonres*latres*depthres\n            temp_idx_out[ind] = linear_idx\n        else\n            temp_idx_out[ind] = 0\n        end\n    else\n        temp_idx_out[ind] = 0\n    end\nend\n\n@kernel function gather_temps_kernel!(temps_out, temp_grid_4d, temp_indices)\n    ind = @index(Global)\n    idx = temp_indices[ind]\n    if idx &gt; 0\n        @inbounds temps_out[ind] = temp_grid_4d[idx]\n    end\nend\n\nfunction individual_temp!(model::MarineModel, sp::Int)\n    arch = model.arch\n    envi = model.environment\n    agent_data = model.individuals.animals[sp].data\n    \n    temp_grid_4d = envi.data[\"temp\"]\n    lonres, latres, depthres, _ = size(temp_grid_4d)\n\n    kernel1 = calculate_temp_indices_kernel!(device(arch), 256, (length(agent_data.x),))\n    kernel1(\n        agent_data.temp_idx, agent_data.alive,\n        agent_data.pool_x, agent_data.pool_y, agent_data.pool_z,\n        envi.ts, lonres, latres, depthres\n    )\n\n    temps_out = array_type(arch)(zeros(eltype(temp_grid_4d), length(agent_data.x)))\n    kernel2 = gather_temps_kernel!(device(arch), 256, (length(agent_data.x),))\n    kernel2(temps_out, temp_grid_4d, agent_data.temp_idx)\n\n    KernelAbstractions.synchronize(device(arch))\n    return temps_out\nend\n\n\n\n\nThis section contains the functions that determine where agents can live and how they are initially placed in the model world.\n\n\nThis function is a critical part of the model setup. It runs on the CPU using multi-threading. For each species, it loops through every grid cell and every month, calculating a habitat suitability index from 0 to 1. This index is based on comparing the environmental data for that cell to the species’ unique preferences (defined in envi_pref.csv). The function uses a “land mask” derived from the temperature data to ensure that any cell corresponding to land is automatically assigned a capacity of zero, which is a crucial step for model stability.\n\n\n\nThis CPU-based function is used to find a starting location for a new agent. It takes the pre-calculated habitat capacity map for a given species and month and performs a weighted random selection to choose a grid cell, with a higher probability of selecting cells with better habitat. This ensures that agents are placed in ecologically plausible locations at the start of the simulation.\n# ===================================================================\n# Habitat Capacity and Agent Placement\n# ===================================================================\n\nfunction initial_habitat_capacity(envi::MarineEnvironment, n_spec::Int, n_resource::Int, files, arch::Architecture, plt_diags)\n    prefs_df = CSV.read(files[files.File .== \"envi_pref\",:Destination][1], DataFrame)\n    trait = Dict(pairs(eachcol(CSV.read(files[files.File .== \"focal_trait\",:Destination][1], DataFrame))))\n    resource = Dict(pairs(eachcol(CSV.read(files[files.File .== \"resource_trait\",:Destination][1], DataFrame))))\n\n    spec_names = vcat(trait[:SpeciesLong][1:n_spec], resource[:SpeciesLong][1:n_resource])\n    \n    envi_data_cpu = Dict{String, Array}()\n    for (name, grid) in envi.data\n        envi_data_cpu[name] = Array(grid)\n    end\n    \n    ref_var = envi_data_cpu[\"temp-surf\"]\n    lonres, latres, nmonths = size(ref_var)\n    \n    land_mask = .!ismissing.(ref_var[:,:,1])\n\n    capacities_cpu = ones(Float64, lonres, latres, nmonths, n_spec + n_resource)\n\n    Threads.@threads for i in 1:length(spec_names)\n        sp_name = spec_names[i]\n        sp_prefs = filter(row -&gt; row.species == sp_name, prefs_df)\n        \n        if !isempty(sp_prefs)\n            for month in 1:nmonths, lat in 1:latres, lon in 1:lonres\n                \n                if !land_mask[lon, lat]\n                    capacities_cpu[lon, lat, month, i] = 0.0\n                    continue\n                end\n\n                suitability_total = 1.0\n                \n                for pref_row in eachrow(sp_prefs)\n                    var_name = pref_row.variable\n                    if !haskey(envi_data_cpu, var_name); continue; end\n                    \n                    env_var_grid = envi_data_cpu[var_name]\n                    val = (ndims(env_var_grid) == 3) ? env_var_grid[lon, lat, month] : env_var_grid[lon, lat]\n\n                    if ismissing(val)\n                        suitability_total = 0.0\n                        break\n                    end\n                    \n                    pref_min = pref_row.pref_min\n                    opt_min = pref_row.opt_min\n                    opt_max = pref_row.opt_max\n                    pref_max = pref_row.pref_max\n\n                    suitability_i = 0.0\n                    if any(ismissing, [pref_min, opt_min, opt_max, pref_max])\n                        suitability_i = 1.0 \n                    else\n                        if val &gt;= opt_min && val &lt;= opt_max\n                            suitability_i = 1.0\n                        elseif val &gt; pref_min && val &lt; opt_min\n                            suitability_i = (val - pref_min) / (opt_min - pref_min)\n                        elseif val &gt; opt_max && val &lt; pref_max\n                            suitability_i = (pref_max - val) / (pref_max - opt_max)\n                        end\n                    end\n                    \n                    suitability_total *= suitability_i\n                end\n                \n                capacities_cpu[lon, lat, month, i] = suitability_total\n            end\n        end\n    end\n    \n    if plt_diags == 1\n        output_dir = \"./results/Test/Capacities\"\n        mkpath(output_dir)\n\n        for i in 1:length(spec_names)\n            sp_name = spec_names[i]\n            for month in 1:nmonths\n                capacity_slice = capacities_cpu[:, :, month, i]\n                p = heatmap(\n                    capacity_slice', \n                    title = \"Habitat Capacity: $sp_name - Month $month\",\n                    xlabel = \"Longitude Index\",\n                    ylabel = \"Latitude Index\",\n                    c = :viridis,\n                    clims = (0, 1)\n                )\n                savefig(p, joinpath(output_dir, \"$(sp_name)_month_$(month)_capacity.png\"))\n            end\n        end\n        @info \"Habitat capacity maps exported to $output_dir\"\n    end\n\n    return array_type(arch)(capacities_cpu)\nend\n\nfunction initial_ind_placement(df_cpu, sp, grid, n_selections, month, land_mask)\n    latmax = grid[grid.Name .== \"yulcorner\", :Value][1]\n    lonmin = grid[grid.Name .== \"xllcorner\", :Value][1]\n    cell_size = grid[grid.Name .== \"cellsize\", :Value][1]\n\n    lonres, latres = size(land_mask)\n\n    capacity_slice = @view df_cpu[:, :, month, sp]\n    \n    valid_cells = DataFrame(x=Int[], y=Int[], value=Float64[])\n    for lon in 1:lonres, lat in 1:latres\n        if land_mask[lon, lat] && capacity_slice[lon, lat] &gt; 0\n            push!(valid_cells, (x=lon, y=lat, value=capacity_slice[lon, lat]))\n        end\n    end\n\n    if nrow(valid_cells) &gt; 0\n        sort!(valid_cells, :value, rev=true)\n        cumvals = cumsum(valid_cells.value)\n        total = cumvals[end]\n\n        x_values, y_values = Int[], Int[]\n        for _ in 1:n_selections\n            r = (rand()^2) * total\n            selected_idx = findfirst(cumvals .&gt;= r)\n            if selected_idx === nothing; selected_idx = 1; end\n            push!(x_values, valid_cells.x[selected_idx])\n            push!(y_values, valid_cells.y[selected_idx])\n        end\n\n        actual_x = lonmin .+ (x_values .- 1) .* cell_size .+ rand(n_selections) .* cell_size\n        actual_y = latmax .- (y_values .- 1) .* cell_size .- rand(n_selections) .* cell_size\n\n        return (lons=actual_x, lats=actual_y, grid_x=x_values, grid_y=y_values)\n    else\n        @warn \"No valid water-based habitat for species $sp in month $month. Placing randomly.\"\n        x_values = rand(1:lonres, n_selections)\n        y_values = rand(1:latres, n_selections)\n        actual_x = lonmin .+ (x_values .- 1) .* cell_size .+ rand(n_selections) .* cell_size\n        actual_y = latmax .- (y_values .- 1) .* cell_size .- rand(n_selections) .* cell_size\n        return (lons=actual_x, lats=actual_y, grid_x=x_values, grid_y=y_values)\n    end\nend",
    "crumbs": [
      "Model Components",
      "Environmental Factors"
    ]
  },
  {
    "objectID": "components/environment.html#environmental-factors",
    "href": "components/environment.html#environmental-factors",
    "title": "SwimmingIndividuals.jl",
    "section": "",
    "text": "The environment.jl file is the cornerstone of the model’s physical world. It contains the functions responsible for loading environmental data from external files, calculating habitat suitability for each species, placing agents into the world, and allowing agents to sense their local conditions.\n\n\nThe simulation begins by loading all necessary environmental data grids from a single NetCDF file (environment.nc).\n\n\nThis is the primary function for setting up the model’s environment. It reads the specified NetCDF file, loads each variable (e.g., temp, salinity, bathymetry) into memory, and moves the data to the appropriate computational architecture (CPU or GPU). As a diagnostic step, it also generates and saves a plot of the surface layer for each variable to help the user verify that the data has been loaded correctly.\n# ===================================================================\n# Data Structures and Environment Loading\n# ===================================================================\n\nfunction generate_environment!(arch::Architecture, nc_file::String,plt_diags)\n    ds = NCDataset(nc_file)\n    envi_data = Dict{String, AbstractArray}()\n    output_dir = \"./results/Test/Environment\"\n    mkpath(output_dir)\n    @info \"Saving environment plots to: $output_dir\"\n\n    for var_name in keys(ds)\n        if var_name in [\"lon\", \"lat\", \"depth\", \"time\"]\n            continue\n        end\n        \n        @info \"Loading and plotting environmental variable: $var_name\"\n        \n        data_cpu = ds[var_name]\n        envi_data[var_name] = array_type(arch)(data_cpu)\n\n        # Plotting logic\n        if plt_diags == 1\n            local surface_slice\n            if ndims(data_cpu) &gt;= 3\n                if ndims(data_cpu) == 4\n                    surface_slice = data_cpu[:, :, 1, 1]\n                else # 3D\n                    surface_slice = data_cpu[:, :, 1]\n                end\n            elseif ndims(data_cpu) == 2\n                surface_slice = data_cpu\n            else\n                @warn \"Skipping plot for variable '$var_name' with unsupported dimensions.\"\n                continue\n            end\n\n            p = heatmap(\n                surface_slice',\n                title = \"Surface Layer: $var_name (Month 1)\",\n                xlabel = \"Longitude Index\",\n                ylabel = \"Latitude Index\",\n                c = :viridis\n            )\n            savefig(p, joinpath(output_dir, \"$(var_name)_surface.png\"))\n        end\n    end\n\n    close(ds)\n    return MarineEnvironment(envi_data, 1)\nend\n\n\n\n\nThis system allows each agent to determine the ambient water temperature at its specific location in the 3D grid. It uses a high-performance, two-kernel “Index-Gather” pattern to do this efficiently on the GPU.\n\n\nThis is the main launcher function. It first calls calculate_temp_indices_kernel! to have each agent determine its linear index into the 4D temperature grid. It then calls gather_temps_kernel! to perform a highly efficient lookup using these pre-calculated indices.\n# ===================================================================\n# Agent Temperature Sensing System\n# ===================================================================\n\n@kernel function calculate_temp_indices_kernel!(\n    temp_idx_out, alive, pool_x, pool_y, pool_z,\n    envi_ts, lonres, latres, depthres\n)\n    ind = @index(Global)\n    @inbounds if alive[ind] == 1.0\n        x, y, z = pool_x[ind], pool_y[ind], pool_z[ind]\n        if 1 &lt;= x &lt;= lonres && 1 &lt;= y &lt;= latres && 1 &lt;= z &lt;= depthres\n            linear_idx = x + (y-1)*lonres + (z-1)*lonres*latres + (envi_ts-1)*lonres*latres*depthres\n            temp_idx_out[ind] = linear_idx\n        else\n            temp_idx_out[ind] = 0\n        end\n    else\n        temp_idx_out[ind] = 0\n    end\nend\n\n@kernel function gather_temps_kernel!(temps_out, temp_grid_4d, temp_indices)\n    ind = @index(Global)\n    idx = temp_indices[ind]\n    if idx &gt; 0\n        @inbounds temps_out[ind] = temp_grid_4d[idx]\n    end\nend\n\nfunction individual_temp!(model::MarineModel, sp::Int)\n    arch = model.arch\n    envi = model.environment\n    agent_data = model.individuals.animals[sp].data\n    \n    temp_grid_4d = envi.data[\"temp\"]\n    lonres, latres, depthres, _ = size(temp_grid_4d)\n\n    kernel1 = calculate_temp_indices_kernel!(device(arch), 256, (length(agent_data.x),))\n    kernel1(\n        agent_data.temp_idx, agent_data.alive,\n        agent_data.pool_x, agent_data.pool_y, agent_data.pool_z,\n        envi.ts, lonres, latres, depthres\n    )\n\n    temps_out = array_type(arch)(zeros(eltype(temp_grid_4d), length(agent_data.x)))\n    kernel2 = gather_temps_kernel!(device(arch), 256, (length(agent_data.x),))\n    kernel2(temps_out, temp_grid_4d, agent_data.temp_idx)\n\n    KernelAbstractions.synchronize(device(arch))\n    return temps_out\nend\n\n\n\n\nThis section contains the functions that determine where agents can live and how they are initially placed in the model world.\n\n\nThis function is a critical part of the model setup. It runs on the CPU using multi-threading. For each species, it loops through every grid cell and every month, calculating a habitat suitability index from 0 to 1. This index is based on comparing the environmental data for that cell to the species’ unique preferences (defined in envi_pref.csv). The function uses a “land mask” derived from the temperature data to ensure that any cell corresponding to land is automatically assigned a capacity of zero, which is a crucial step for model stability.\n\n\n\nThis CPU-based function is used to find a starting location for a new agent. It takes the pre-calculated habitat capacity map for a given species and month and performs a weighted random selection to choose a grid cell, with a higher probability of selecting cells with better habitat. This ensures that agents are placed in ecologically plausible locations at the start of the simulation.\n# ===================================================================\n# Habitat Capacity and Agent Placement\n# ===================================================================\n\nfunction initial_habitat_capacity(envi::MarineEnvironment, n_spec::Int, n_resource::Int, files, arch::Architecture, plt_diags)\n    prefs_df = CSV.read(files[files.File .== \"envi_pref\",:Destination][1], DataFrame)\n    trait = Dict(pairs(eachcol(CSV.read(files[files.File .== \"focal_trait\",:Destination][1], DataFrame))))\n    resource = Dict(pairs(eachcol(CSV.read(files[files.File .== \"resource_trait\",:Destination][1], DataFrame))))\n\n    spec_names = vcat(trait[:SpeciesLong][1:n_spec], resource[:SpeciesLong][1:n_resource])\n    \n    envi_data_cpu = Dict{String, Array}()\n    for (name, grid) in envi.data\n        envi_data_cpu[name] = Array(grid)\n    end\n    \n    ref_var = envi_data_cpu[\"temp-surf\"]\n    lonres, latres, nmonths = size(ref_var)\n    \n    land_mask = .!ismissing.(ref_var[:,:,1])\n\n    capacities_cpu = ones(Float64, lonres, latres, nmonths, n_spec + n_resource)\n\n    Threads.@threads for i in 1:length(spec_names)\n        sp_name = spec_names[i]\n        sp_prefs = filter(row -&gt; row.species == sp_name, prefs_df)\n        \n        if !isempty(sp_prefs)\n            for month in 1:nmonths, lat in 1:latres, lon in 1:lonres\n                \n                if !land_mask[lon, lat]\n                    capacities_cpu[lon, lat, month, i] = 0.0\n                    continue\n                end\n\n                suitability_total = 1.0\n                \n                for pref_row in eachrow(sp_prefs)\n                    var_name = pref_row.variable\n                    if !haskey(envi_data_cpu, var_name); continue; end\n                    \n                    env_var_grid = envi_data_cpu[var_name]\n                    val = (ndims(env_var_grid) == 3) ? env_var_grid[lon, lat, month] : env_var_grid[lon, lat]\n\n                    if ismissing(val)\n                        suitability_total = 0.0\n                        break\n                    end\n                    \n                    pref_min = pref_row.pref_min\n                    opt_min = pref_row.opt_min\n                    opt_max = pref_row.opt_max\n                    pref_max = pref_row.pref_max\n\n                    suitability_i = 0.0\n                    if any(ismissing, [pref_min, opt_min, opt_max, pref_max])\n                        suitability_i = 1.0 \n                    else\n                        if val &gt;= opt_min && val &lt;= opt_max\n                            suitability_i = 1.0\n                        elseif val &gt; pref_min && val &lt; opt_min\n                            suitability_i = (val - pref_min) / (opt_min - pref_min)\n                        elseif val &gt; opt_max && val &lt; pref_max\n                            suitability_i = (pref_max - val) / (pref_max - opt_max)\n                        end\n                    end\n                    \n                    suitability_total *= suitability_i\n                end\n                \n                capacities_cpu[lon, lat, month, i] = suitability_total\n            end\n        end\n    end\n    \n    if plt_diags == 1\n        output_dir = \"./results/Test/Capacities\"\n        mkpath(output_dir)\n\n        for i in 1:length(spec_names)\n            sp_name = spec_names[i]\n            for month in 1:nmonths\n                capacity_slice = capacities_cpu[:, :, month, i]\n                p = heatmap(\n                    capacity_slice', \n                    title = \"Habitat Capacity: $sp_name - Month $month\",\n                    xlabel = \"Longitude Index\",\n                    ylabel = \"Latitude Index\",\n                    c = :viridis,\n                    clims = (0, 1)\n                )\n                savefig(p, joinpath(output_dir, \"$(sp_name)_month_$(month)_capacity.png\"))\n            end\n        end\n        @info \"Habitat capacity maps exported to $output_dir\"\n    end\n\n    return array_type(arch)(capacities_cpu)\nend\n\nfunction initial_ind_placement(df_cpu, sp, grid, n_selections, month, land_mask)\n    latmax = grid[grid.Name .== \"yulcorner\", :Value][1]\n    lonmin = grid[grid.Name .== \"xllcorner\", :Value][1]\n    cell_size = grid[grid.Name .== \"cellsize\", :Value][1]\n\n    lonres, latres = size(land_mask)\n\n    capacity_slice = @view df_cpu[:, :, month, sp]\n    \n    valid_cells = DataFrame(x=Int[], y=Int[], value=Float64[])\n    for lon in 1:lonres, lat in 1:latres\n        if land_mask[lon, lat] && capacity_slice[lon, lat] &gt; 0\n            push!(valid_cells, (x=lon, y=lat, value=capacity_slice[lon, lat]))\n        end\n    end\n\n    if nrow(valid_cells) &gt; 0\n        sort!(valid_cells, :value, rev=true)\n        cumvals = cumsum(valid_cells.value)\n        total = cumvals[end]\n\n        x_values, y_values = Int[], Int[]\n        for _ in 1:n_selections\n            r = (rand()^2) * total\n            selected_idx = findfirst(cumvals .&gt;= r)\n            if selected_idx === nothing; selected_idx = 1; end\n            push!(x_values, valid_cells.x[selected_idx])\n            push!(y_values, valid_cells.y[selected_idx])\n        end\n\n        actual_x = lonmin .+ (x_values .- 1) .* cell_size .+ rand(n_selections) .* cell_size\n        actual_y = latmax .- (y_values .- 1) .* cell_size .- rand(n_selections) .* cell_size\n\n        return (lons=actual_x, lats=actual_y, grid_x=x_values, grid_y=y_values)\n    else\n        @warn \"No valid water-based habitat for species $sp in month $month. Placing randomly.\"\n        x_values = rand(1:lonres, n_selections)\n        y_values = rand(1:latres, n_selections)\n        actual_x = lonmin .+ (x_values .- 1) .* cell_size .+ rand(n_selections) .* cell_size\n        actual_y = latmax .- (y_values .- 1) .* cell_size .- rand(n_selections) .* cell_size\n        return (lons=actual_x, lats=actual_y, grid_x=x_values, grid_y=y_values)\n    end\nend",
    "crumbs": [
      "Model Components",
      "Environmental Factors"
    ]
  },
  {
    "objectID": "components/mortality.html",
    "href": "components/mortality.html",
    "title": "SwimmingIndividuals.jl",
    "section": "",
    "text": "The mortality.jl file is responsible for applying background mortality to the resource populations. This represents natural death from sources other than direct predation by the focal species agents (e.g., disease, predation by un-modeled organisms, old age).\n\n\nThis system uses a high-performance GPU kernel to apply a continuous background mortality rate (Z) to every cell in the resource biomass grid at each timestep.\n\n\nThis is the main launcher function for the resource mortality submodel. It prepares the necessary data (the resource trait parameters) in a GPU-compatible format and then calls the resource_mortality_kernel! to run in parallel across the entire resource grid.\n\n\n\nThis GPU kernel is the core of the natural mortality calculation. Each thread is responsible for a single grid cell (longitude, latitude, depth) for a single resource species. It calculates the proportion of biomass that should survive the timestep based on the species’ annual natural mortality rate (Z) and updates the biomass in that cell accordingly.\n```julia @kernel function resource_mortality_kernel!(biomass_grid, resource_trait, dt) lon, lat, depth, sp = @index(Global, NTuple)\nbiomass = biomass_grid[lon, lat, depth, sp]\nif biomass &gt; 0\n    # Get the annual natural mortality rate for this species\n    z_rate = resource_trait.Z[sp]\n    # Convert the annual rate to a per-minute rate\n    z_per_minute = z_rate / (365 * 1440)\n    # Calculate the proportion of biomass surviving this timestep using the continuous mortality equation\n    proportion_surviving = exp(-z_per_minute * dt)\n    # Update the biomass in the grid cell\n    @inbounds biomass_grid[lon, lat, depth, sp] = biomass * proportion_surviving\nend\nend\nfunction resource_mortality!(model::MarineModel) arch = model.arch # Convert the resource trait DataFrame to a GPU-compatible NamedTuple of arrays trait_gpu = (; (Symbol(c) =&gt; array_type(arch)(model.resource_trait[:, c]) for c in names(model.resource_trait))…)\n# Set up and launch the kernel to run over the entire 4D resource grid\nkernel! = resource_mortality_kernel!(device(arch), (8, 8, 4, 1), size(model.resources.biomass))\n# Pass only the biomass grid to be modified\nkernel!(model.resources.biomass, trait_gpu, model.dt)\nKernelAbstractions.synchronize(device(arch))\nend",
    "crumbs": [
      "Model Components",
      "Mortality & Natural Loss"
    ]
  },
  {
    "objectID": "components/mortality.html#mortality-natural-loss",
    "href": "components/mortality.html#mortality-natural-loss",
    "title": "SwimmingIndividuals.jl",
    "section": "",
    "text": "The mortality.jl file is responsible for applying background mortality to the resource populations. This represents natural death from sources other than direct predation by the focal species agents (e.g., disease, predation by un-modeled organisms, old age).\n\n\nThis system uses a high-performance GPU kernel to apply a continuous background mortality rate (Z) to every cell in the resource biomass grid at each timestep.\n\n\nThis is the main launcher function for the resource mortality submodel. It prepares the necessary data (the resource trait parameters) in a GPU-compatible format and then calls the resource_mortality_kernel! to run in parallel across the entire resource grid.\n\n\n\nThis GPU kernel is the core of the natural mortality calculation. Each thread is responsible for a single grid cell (longitude, latitude, depth) for a single resource species. It calculates the proportion of biomass that should survive the timestep based on the species’ annual natural mortality rate (Z) and updates the biomass in that cell accordingly.\n```julia @kernel function resource_mortality_kernel!(biomass_grid, resource_trait, dt) lon, lat, depth, sp = @index(Global, NTuple)\nbiomass = biomass_grid[lon, lat, depth, sp]\nif biomass &gt; 0\n    # Get the annual natural mortality rate for this species\n    z_rate = resource_trait.Z[sp]\n    # Convert the annual rate to a per-minute rate\n    z_per_minute = z_rate / (365 * 1440)\n    # Calculate the proportion of biomass surviving this timestep using the continuous mortality equation\n    proportion_surviving = exp(-z_per_minute * dt)\n    # Update the biomass in the grid cell\n    @inbounds biomass_grid[lon, lat, depth, sp] = biomass * proportion_surviving\nend\nend\nfunction resource_mortality!(model::MarineModel) arch = model.arch # Convert the resource trait DataFrame to a GPU-compatible NamedTuple of arrays trait_gpu = (; (Symbol(c) =&gt; array_type(arch)(model.resource_trait[:, c]) for c in names(model.resource_trait))…)\n# Set up and launch the kernel to run over the entire 4D resource grid\nkernel! = resource_mortality_kernel!(device(arch), (8, 8, 4, 1), size(model.resources.biomass))\n# Pass only the biomass grid to be modified\nkernel!(model.resources.biomass, trait_gpu, model.dt)\nKernelAbstractions.synchronize(device(arch))\nend",
    "crumbs": [
      "Model Components",
      "Mortality & Natural Loss"
    ]
  },
  {
    "objectID": "components/output.html",
    "href": "components/output.html",
    "title": "SwimmingIndividuals.jl",
    "section": "",
    "text": "These two files work together to handle all aspects of saving and processing the results of a simulation. The output.jl file is responsible for creating the data structures that hold the results, while the analysis.jl file contains the functions that process the raw model state into meaningful scientific outputs.\n\n\nThis file defines the MarineOutputs struct and the function that initializes it.\n\n\nThis function is called once at the beginning of a simulation to create all the large, multi-dimensional arrays needed to store the results. It is architecture-aware, meaning it will create standard Arrays for a CPU simulation and CuArrays for a GPU simulation. This ensures that the output arrays reside on the same device as the agent data, which is crucial for performance. The function creates grids to store spatially explicit data on mortalities, fishing mortality, consumption, and abundance.\n# In output.jl\n\n# ===================================================================\n# Data Structures and Functions for Model Output\n# ===================================================================\n\n\"\"\"\n    generate_outputs(model::MarineModel)\nThis function creates the data structures for storing simulation results.\nIt is architecture-aware and will create arrays on the GPU if the model\nis configured to run on a GPU.\n\"\"\"\nfunction generate_outputs(model::MarineModel)\n    arch = model.arch\n    grid = model.depths.grid\n    \n    # Get grid dimensions\n    depthres = Int(grid[grid.Name .== \"depthres\", :Value][1])\n    latres = Int(grid[grid.Name .== \"latres\", :Value][1])\n    lonres = Int(grid[grid.Name .== \"lonres\", :Value][1])\n    n_fish = length(model.fishing)\n\n    # --- Create output arrays on the correct device (CPU or GPU) ---\n    mortalities = array_type(arch)(zeros(Int64, lonres, latres, depthres, model.n_species + model.n_resource, model.n_species))\n    Fmort = array_type(arch)(zeros(Int64, lonres, latres, depthres, n_fish, model.n_species))\n    consumption = array_type(arch)(zeros(Float64, lonres, latres, depthres, model.n_species + model.n_resource, model.n_species + model.n_resource))\n    abundance = array_type(arch)(zeros(Float64, lonres, latres, depthres, model.n_species + model.n_resource))\n    \n    return MarineOutputs(mortalities, Fmort, consumption, abundance)\nend\n\n\n\n\nThis file contains the functions that perform the analysis at each output step, converting raw data (like the number of deaths) into standard scientific metrics (like instantaneous mortality rates) and saving the results to files.\n\n\nThese are the high-performance GPU kernels that form the core of the analysis system.\n\n\n\n\n\n\n# ===================================================================\n# GPU-Compliant Analysis Kernels\n# ===================================================================\n\n@kernel function mortality_rate_kernel!(Rate, abundance, mortality)\n    # Each thread gets a multi-dimensional index for the mortality array\n    idx = @index(Global, Cartesian)\n    \n    @inbounds if mortality[idx] &gt; 0\n        abund_val = abundance[idx[1], idx[2], idx[3], idx[5]]\n        \n        @inbounds if abund_val &gt; 0\n            # Use the element type of the output array for all calculations\n            FT = eltype(Rate)\n            \n            mort_val::FT = mortality[idx]\n            \n            mort_frac = mort_val / abund_val\n            mort_frac = clamp(mort_frac, FT(0.0), FT(1.0))\n            \n            # Avoid log(0) which results in -Inf\n            if mort_frac &lt; FT(1.0)\n                Rate[idx] = -log(FT(1.0) - mort_frac)\n            else\n                Rate[idx] = FT(10.0) # Use a large, finite number for 100% mortality\n            end\n        end\n    end\nend\n\n# Kernel to calculate the abundance of agents in each grid cell.\n@kernel function init_abundances_kernel!(abundance_out, agents, sp_idx)\n    i = @index(Global) # Each thread handles one agent\n\n    @inbounds if agents.alive[i] == 1.0\n        # Get the agent's grid cell coordinates\n        x = agents.pool_x[i]\n        y = agents.pool_y[i]\n        z = agents.pool_z[i]\n        \n        # Atomically add this agent's abundance to its cell in the 4D grid\n        @atomic abundance_out[x, y, z, sp_idx] += agents.abundance[i]\n    end\nend\n\n\n\n\nThese functions are the high-level wrappers that prepare the data and launch the analysis kernels.\n# ===================================================================\n# Launcher Functions for Analysis\n# ===================================================================\n\nfunction instantaneous_mortality(outputs::MarineOutputs, arch)\n    # Allocate the output array on the correct device\n    M = array_type(arch)(zeros(Float32, size(outputs.mortalities)...))\n    \n    # Launch the kernel with a 5D grid matching the mortality array\n    kernel! = mortality_rate_kernel!(device(arch), (8,8,4,4,1), size(M))\n    kernel!(M, outputs.abundance, outputs.mortalities)\n    KernelAbstractions.synchronize(device(arch))\n    \n    return M\nend\n\nfunction fishing_mortality(outputs::MarineOutputs, arch)\n    # Allocate the output array on the correct device\n    F = array_type(arch)(zeros(Float32, size(outputs.Fmort)...))\n\n    # The same kernel can be used for fishing mortality\n    kernel! = mortality_rate_kernel!(device(arch), (8,8,4,4,1), size(F))\n    kernel!(F, outputs.abundance, outputs.Fmort)\n    KernelAbstractions.synchronize(device(arch))\n\n    return F\nend\n\n# This launcher calculates abundances for ALL species at once.\nfunction init_abundances!(model::MarineModel, outputs::MarineOutputs)\n    arch = model.arch\n    \n    # Reset the abundance array on the device before calculating\n    fill!(outputs.abundance, 0.0)\n\n    # Launch a separate kernel for each species\n    for sp in 1:model.n_species\n        agents = model.individuals.animals[sp].data\n        n_agents = length(agents.x)\n        \n        if n_agents &gt; 0\n            kernel! = init_abundances_kernel!(device(arch), 256, (n_agents,))\n            kernel!(outputs.abundance, agents, sp)\n        end\n    end\n    \n    # Wait for all kernels to finish before proceeding\n    KernelAbstractions.synchronize(device(arch))\n    return nothing\nend\n\n\n\nThese are the main functions called from the TimeStep! loop to save the results.\n\n\n\n\n\n# ===================================================================\n# Top-Level Output Functions\n# ===================================================================\n\nfunction timestep_results(sim::MarineSimulation)\n    model = sim.model\n    outputs = sim.outputs\n    arch = model.arch\n    ts = Int(model.iteration)\n    run = Int(sim.run)\n\n    # --- Gather individual data for CSV output ---\n    # This logic is inherently CPU-based and requires copying data.\n    Sp, Ind, x, y, z, lengths, abundance, biomass = [],[],[],[],[],[],[],[]\n\n    for (species_index, animal) in enumerate(model.individuals.animals)\n        spec_dat = animal.data\n        \n        # Findall must be on a CPU array\n        cpu_alive_mask = Array(spec_dat.alive) .== 1.0\n        alive_indices = findall(cpu_alive_mask)\n        if isempty(alive_indices); continue; end\n\n        # Copy only the data for living individuals\n        append!(Sp, fill(species_index, length(alive_indices)))\n        append!(Ind, alive_indices)\n        append!(x, Array(spec_dat.x[alive_indices]))\n        append!(y, Array(spec_dat.y[alive_indices]))\n        append!(z, Array(spec_dat.z[alive_indices]))\n        append!(lengths, Array(spec_dat.length[alive_indices]))\n        append!(abundance, Array(spec_dat.abundance[alive_indices]))\n        append!(biomass, Array(spec_dat.biomass_school[alive_indices]))\n    end\n\n    if !isempty(Sp)\n        # Create and write DataFrame on CPU\n        df = DataFrame(Species=Sp, Individual=Ind, X=x, Y=y, Z=z, Length=lengths, Abundance=abundance, Biomass=biomass)\n        CSV.write(\"results/Individual/IndividualResults_$run-$ts.csv\", df)\n    end\n    \n    # --- Calculate and save population-scale results ---\n    init_abundances!(model, outputs) # Calculate abundances before mortality rates\n    M = instantaneous_mortality(outputs, arch)\n    F = fishing_mortality(outputs, arch)\n    \n    # Copy results to CPU for saving to HDF5\n    cpu_M = Array(M)\n    cpu_F = Array(F)\n    cpu_DC = Array(outputs.consumption)\n\n    h5open(\"results/Population/Instantaneous_Mort_$(run)-$(ts).h5\", \"w\") do file\n        write(file, \"M\", cpu_M)\n        write(file, \"F\", cpu_F)\n        write(file, \"Diet\", cpu_DC)\n    end\n\n    # --- Reset output arrays on the device ---\n    fill!(outputs.mortalities, 0)\n    fill!(outputs.Fmort, 0)\n    fill!(outputs.consumption, 0.0)\n    \n    return nothing\nend\n\n# This function is entirely CPU-based and does not need modification.\nfunction fishery_results(sim::MarineSimulation)\n    ts = Int(sim.model.iteration)\n    run = Int(sim.run)\n    fisheries = sim.model.fishing\n\n    name, quotas, catches_t, catches_ind = [], [], [], []\n    \n    for fishery in fisheries\n        push!(name, fishery.name)\n        push!(quotas, fishery.quota)\n        push!(catches_t, fishery.cumulative_catch)\n        push!(catches_ind, fishery.cumulative_inds)\n    end\n\n    df = DataFrame(Name=name, Quota=quotas, Tonnage=catches_t, Individuals=catches_ind)\n    CSV.write(\"results/Fishery/FisheryResults_$run-$ts.csv\", df)\nend",
    "crumbs": [
      "Model Components",
      "Model Outputs & Analysis"
    ]
  },
  {
    "objectID": "components/output.html#model-outputs-analysis",
    "href": "components/output.html#model-outputs-analysis",
    "title": "SwimmingIndividuals.jl",
    "section": "",
    "text": "These two files work together to handle all aspects of saving and processing the results of a simulation. The output.jl file is responsible for creating the data structures that hold the results, while the analysis.jl file contains the functions that process the raw model state into meaningful scientific outputs.\n\n\nThis file defines the MarineOutputs struct and the function that initializes it.\n\n\nThis function is called once at the beginning of a simulation to create all the large, multi-dimensional arrays needed to store the results. It is architecture-aware, meaning it will create standard Arrays for a CPU simulation and CuArrays for a GPU simulation. This ensures that the output arrays reside on the same device as the agent data, which is crucial for performance. The function creates grids to store spatially explicit data on mortalities, fishing mortality, consumption, and abundance.\n# In output.jl\n\n# ===================================================================\n# Data Structures and Functions for Model Output\n# ===================================================================\n\n\"\"\"\n    generate_outputs(model::MarineModel)\nThis function creates the data structures for storing simulation results.\nIt is architecture-aware and will create arrays on the GPU if the model\nis configured to run on a GPU.\n\"\"\"\nfunction generate_outputs(model::MarineModel)\n    arch = model.arch\n    grid = model.depths.grid\n    \n    # Get grid dimensions\n    depthres = Int(grid[grid.Name .== \"depthres\", :Value][1])\n    latres = Int(grid[grid.Name .== \"latres\", :Value][1])\n    lonres = Int(grid[grid.Name .== \"lonres\", :Value][1])\n    n_fish = length(model.fishing)\n\n    # --- Create output arrays on the correct device (CPU or GPU) ---\n    mortalities = array_type(arch)(zeros(Int64, lonres, latres, depthres, model.n_species + model.n_resource, model.n_species))\n    Fmort = array_type(arch)(zeros(Int64, lonres, latres, depthres, n_fish, model.n_species))\n    consumption = array_type(arch)(zeros(Float64, lonres, latres, depthres, model.n_species + model.n_resource, model.n_species + model.n_resource))\n    abundance = array_type(arch)(zeros(Float64, lonres, latres, depthres, model.n_species + model.n_resource))\n    \n    return MarineOutputs(mortalities, Fmort, consumption, abundance)\nend\n\n\n\n\nThis file contains the functions that perform the analysis at each output step, converting raw data (like the number of deaths) into standard scientific metrics (like instantaneous mortality rates) and saving the results to files.\n\n\nThese are the high-performance GPU kernels that form the core of the analysis system.\n\n\n\n\n\n\n# ===================================================================\n# GPU-Compliant Analysis Kernels\n# ===================================================================\n\n@kernel function mortality_rate_kernel!(Rate, abundance, mortality)\n    # Each thread gets a multi-dimensional index for the mortality array\n    idx = @index(Global, Cartesian)\n    \n    @inbounds if mortality[idx] &gt; 0\n        abund_val = abundance[idx[1], idx[2], idx[3], idx[5]]\n        \n        @inbounds if abund_val &gt; 0\n            # Use the element type of the output array for all calculations\n            FT = eltype(Rate)\n            \n            mort_val::FT = mortality[idx]\n            \n            mort_frac = mort_val / abund_val\n            mort_frac = clamp(mort_frac, FT(0.0), FT(1.0))\n            \n            # Avoid log(0) which results in -Inf\n            if mort_frac &lt; FT(1.0)\n                Rate[idx] = -log(FT(1.0) - mort_frac)\n            else\n                Rate[idx] = FT(10.0) # Use a large, finite number for 100% mortality\n            end\n        end\n    end\nend\n\n# Kernel to calculate the abundance of agents in each grid cell.\n@kernel function init_abundances_kernel!(abundance_out, agents, sp_idx)\n    i = @index(Global) # Each thread handles one agent\n\n    @inbounds if agents.alive[i] == 1.0\n        # Get the agent's grid cell coordinates\n        x = agents.pool_x[i]\n        y = agents.pool_y[i]\n        z = agents.pool_z[i]\n        \n        # Atomically add this agent's abundance to its cell in the 4D grid\n        @atomic abundance_out[x, y, z, sp_idx] += agents.abundance[i]\n    end\nend\n\n\n\n\nThese functions are the high-level wrappers that prepare the data and launch the analysis kernels.\n# ===================================================================\n# Launcher Functions for Analysis\n# ===================================================================\n\nfunction instantaneous_mortality(outputs::MarineOutputs, arch)\n    # Allocate the output array on the correct device\n    M = array_type(arch)(zeros(Float32, size(outputs.mortalities)...))\n    \n    # Launch the kernel with a 5D grid matching the mortality array\n    kernel! = mortality_rate_kernel!(device(arch), (8,8,4,4,1), size(M))\n    kernel!(M, outputs.abundance, outputs.mortalities)\n    KernelAbstractions.synchronize(device(arch))\n    \n    return M\nend\n\nfunction fishing_mortality(outputs::MarineOutputs, arch)\n    # Allocate the output array on the correct device\n    F = array_type(arch)(zeros(Float32, size(outputs.Fmort)...))\n\n    # The same kernel can be used for fishing mortality\n    kernel! = mortality_rate_kernel!(device(arch), (8,8,4,4,1), size(F))\n    kernel!(F, outputs.abundance, outputs.Fmort)\n    KernelAbstractions.synchronize(device(arch))\n\n    return F\nend\n\n# This launcher calculates abundances for ALL species at once.\nfunction init_abundances!(model::MarineModel, outputs::MarineOutputs)\n    arch = model.arch\n    \n    # Reset the abundance array on the device before calculating\n    fill!(outputs.abundance, 0.0)\n\n    # Launch a separate kernel for each species\n    for sp in 1:model.n_species\n        agents = model.individuals.animals[sp].data\n        n_agents = length(agents.x)\n        \n        if n_agents &gt; 0\n            kernel! = init_abundances_kernel!(device(arch), 256, (n_agents,))\n            kernel!(outputs.abundance, agents, sp)\n        end\n    end\n    \n    # Wait for all kernels to finish before proceeding\n    KernelAbstractions.synchronize(device(arch))\n    return nothing\nend\n\n\n\nThese are the main functions called from the TimeStep! loop to save the results.\n\n\n\n\n\n# ===================================================================\n# Top-Level Output Functions\n# ===================================================================\n\nfunction timestep_results(sim::MarineSimulation)\n    model = sim.model\n    outputs = sim.outputs\n    arch = model.arch\n    ts = Int(model.iteration)\n    run = Int(sim.run)\n\n    # --- Gather individual data for CSV output ---\n    # This logic is inherently CPU-based and requires copying data.\n    Sp, Ind, x, y, z, lengths, abundance, biomass = [],[],[],[],[],[],[],[]\n\n    for (species_index, animal) in enumerate(model.individuals.animals)\n        spec_dat = animal.data\n        \n        # Findall must be on a CPU array\n        cpu_alive_mask = Array(spec_dat.alive) .== 1.0\n        alive_indices = findall(cpu_alive_mask)\n        if isempty(alive_indices); continue; end\n\n        # Copy only the data for living individuals\n        append!(Sp, fill(species_index, length(alive_indices)))\n        append!(Ind, alive_indices)\n        append!(x, Array(spec_dat.x[alive_indices]))\n        append!(y, Array(spec_dat.y[alive_indices]))\n        append!(z, Array(spec_dat.z[alive_indices]))\n        append!(lengths, Array(spec_dat.length[alive_indices]))\n        append!(abundance, Array(spec_dat.abundance[alive_indices]))\n        append!(biomass, Array(spec_dat.biomass_school[alive_indices]))\n    end\n\n    if !isempty(Sp)\n        # Create and write DataFrame on CPU\n        df = DataFrame(Species=Sp, Individual=Ind, X=x, Y=y, Z=z, Length=lengths, Abundance=abundance, Biomass=biomass)\n        CSV.write(\"results/Individual/IndividualResults_$run-$ts.csv\", df)\n    end\n    \n    # --- Calculate and save population-scale results ---\n    init_abundances!(model, outputs) # Calculate abundances before mortality rates\n    M = instantaneous_mortality(outputs, arch)\n    F = fishing_mortality(outputs, arch)\n    \n    # Copy results to CPU for saving to HDF5\n    cpu_M = Array(M)\n    cpu_F = Array(F)\n    cpu_DC = Array(outputs.consumption)\n\n    h5open(\"results/Population/Instantaneous_Mort_$(run)-$(ts).h5\", \"w\") do file\n        write(file, \"M\", cpu_M)\n        write(file, \"F\", cpu_F)\n        write(file, \"Diet\", cpu_DC)\n    end\n\n    # --- Reset output arrays on the device ---\n    fill!(outputs.mortalities, 0)\n    fill!(outputs.Fmort, 0)\n    fill!(outputs.consumption, 0.0)\n    \n    return nothing\nend\n\n# This function is entirely CPU-based and does not need modification.\nfunction fishery_results(sim::MarineSimulation)\n    ts = Int(sim.model.iteration)\n    run = Int(sim.run)\n    fisheries = sim.model.fishing\n\n    name, quotas, catches_t, catches_ind = [], [], [], []\n    \n    for fishery in fisheries\n        push!(name, fishery.name)\n        push!(quotas, fishery.quota)\n        push!(catches_t, fishery.cumulative_catch)\n        push!(catches_ind, fishery.cumulative_inds)\n    end\n\n    df = DataFrame(Name=name, Quota=quotas, Tonnage=catches_t, Individuals=catches_ind)\n    CSV.write(\"results/Fishery/FisheryResults_$run-$ts.csv\", df)\nend",
    "crumbs": [
      "Model Components",
      "Model Outputs & Analysis"
    ]
  },
  {
    "objectID": "components/timestep.html",
    "href": "components/timestep.html",
    "title": "SwimmingIndividuals.jl",
    "section": "",
    "text": "The timestep.jl file contains the TimeStep! function, which is the heart of the simulation’s engine. This function is called once for every timestep and is responsible for orchestrating the entire sequence of events, from updating the environment to executing agent behaviors and saving the results.\n\n\nThe function acts as a master conductor, ensuring that all sub-models are called in the correct logical order. At each step, it performs the following key tasks:\n\nAdvance Time: It increments the model’s internal clock and calculates the current month and day of the year.\nUpdate Environment: It checks if a new month has begun. If so, it calls move_resources! to redistribute the resource grids according to the new month’s habitat capacity. It also handles annual resets for fishery quotas.\nProcess Focal Species: It loops through each focal species and, for every living agent, executes the core sub-models in sequence:\n\nbehavior(): Determines the agent’s actions for the timestep.\nindividual_temp!: Allows the agent to sense its local temperature.\nenergy!: Calculates the agent’s full bioenergetics budget.\nfishing!: Applies mortality from any active fisheries.\nThe agent’s age is then incremented.\n\nProcess Resources: It calls the functions that apply background predation, logistic growth, and natural mortality to the resource grids.\nSave Outputs: It checks if the current timestep is a designated output step and, if so, calls the timestep_results and fishery_results functions to save the model state.\nReset Accumulators: It resets any per-timestep variables (like ration and active time) to zero in preparation for the next step.\n\n\n\n\n```julia function TimeStep!(sim::MarineSimulation) # Get references to the main components of the simulation model = sim.model envi = model.environment fisheries = model.fishing outputs = sim.outputs species::Int64 = model.n_species arch = model.arch\n# Advance the model's internal clock\nmodel.iteration += 1\nmodel.t = (model.t + sim.ΔT) % 1440 # Time of day in minutes, resets at midnight\n\n# --- Update Date and Season ---\n# Calculate the current calendar day and month from the iteration number\norigin = DateTime(2025, 1, 1, 0, 0)\nelapsed_minutes = (model.iteration - 1) * sim.ΔT\ncurrent_datetime = origin + Minute(round(Int, elapsed_minutes))\ncurrent_date = Date(current_datetime)\nmonth_index = month(current_date)\nday_index = dayofyear(current_date)\n\n# If the month has changed, redistribute the resource grids\nif month_index != envi.ts\n    move_resources!(model, month_index)\nend\n\n# At the start of a new year, reset fishery quotas\nif day_index == 1\n    (fishery -&gt; (fishery.cumulative_catch = 0; fishery.cumulative_inds = 0)).(fisheries)\nend\n\n# Update the environment's current month\nenvi.ts = month_index\n\n# Print the current date to the console for user feedback\nprint(current_date)\nprint(\": \")\n\n# --- Main Agent Processing Loop ---\n# This loop iterates over each focal species defined in the model\nfor spec in 1:species\n    species_data = model.individuals.animals[spec].data\n    species_chars = model.individuals.animals[spec].p\n\n    # Find all living agents for the current species\n    # This requires a copy from GPU to CPU to use `findall`\n    cpu_alive = Array(species_data.alive)\n    living::Vector{Int64} = findall(x -&gt; x == 1, cpu_alive)\n    \n    if !isempty(living)\n        # --- Calculate and print population summary statistics ---\n        model.abund[spec] = sum(Array(species_data.abundance[living]))\n        model.bioms[spec] = sum(Array(species_data.biomass_school[living]))\n        print(length(living))\n        print(\"  Abundance: \")\n        print(model.abund[spec])\n        print(\"  Mean Length: \")\n        println(mean(Array(species_data.length[living])))\n\n        # --- Execute Agent Sub-models ---\n        print(\"behave | \")\n        behavior(model, spec, living, outputs)\n\n        ind_temp = individual_temp!(model, spec)\n\n        print(\"energy | \")\n        energy!(model, spec, ind_temp, living)\n\n        print(\"fish | \")\n        if (model.iteration &gt; model.spinup)\n            fishing!(model, spec, day_index, outputs)\n        end\n    end\n    \n    # Age all individuals of the species by one timestep\n    species_data.age .+= (model.dt / 1440)\nend\n\nprint(\"resources | \")\n# --- Update Resource Grids ---\nresource_predation!(model, outputs)\nresource_growth!(model)\nresource_mortality!(model)\n\nprintln(\"results | \")\n\n# --- Save Model Output ---\n# Check if the current timestep is an output step\nif (model.t % model.output_dt == 0)\n    timestep_results(sim)\n    if (model.iteration &gt; model.spinup)\n        fishery_results(sim)\n    end\nend\n\n# --- Reset Per-Timestep Accumulators ---\n# Reset variables like ration and active time to zero for all agents\nfor spec in 1:species\n    model.individuals.animals[spec].data.ration .= 0.0\n    model.individuals.animals[spec].data.active .= 0.0\nend\n\n# Annual reset for fisheries\nif day_index == 365\n    (fishery -&gt; (fishery.cumulative_catch = 0; fishery.cumulative_inds = 0)).(fisheries)\nend\nend",
    "crumbs": [
      "Model Components",
      "The Simulation Timestep"
    ]
  },
  {
    "objectID": "components/timestep.html#the-simulation-timestep",
    "href": "components/timestep.html#the-simulation-timestep",
    "title": "SwimmingIndividuals.jl",
    "section": "",
    "text": "The timestep.jl file contains the TimeStep! function, which is the heart of the simulation’s engine. This function is called once for every timestep and is responsible for orchestrating the entire sequence of events, from updating the environment to executing agent behaviors and saving the results.\n\n\nThe function acts as a master conductor, ensuring that all sub-models are called in the correct logical order. At each step, it performs the following key tasks:\n\nAdvance Time: It increments the model’s internal clock and calculates the current month and day of the year.\nUpdate Environment: It checks if a new month has begun. If so, it calls move_resources! to redistribute the resource grids according to the new month’s habitat capacity. It also handles annual resets for fishery quotas.\nProcess Focal Species: It loops through each focal species and, for every living agent, executes the core sub-models in sequence:\n\nbehavior(): Determines the agent’s actions for the timestep.\nindividual_temp!: Allows the agent to sense its local temperature.\nenergy!: Calculates the agent’s full bioenergetics budget.\nfishing!: Applies mortality from any active fisheries.\nThe agent’s age is then incremented.\n\nProcess Resources: It calls the functions that apply background predation, logistic growth, and natural mortality to the resource grids.\nSave Outputs: It checks if the current timestep is a designated output step and, if so, calls the timestep_results and fishery_results functions to save the model state.\nReset Accumulators: It resets any per-timestep variables (like ration and active time) to zero in preparation for the next step.\n\n\n\n\n```julia function TimeStep!(sim::MarineSimulation) # Get references to the main components of the simulation model = sim.model envi = model.environment fisheries = model.fishing outputs = sim.outputs species::Int64 = model.n_species arch = model.arch\n# Advance the model's internal clock\nmodel.iteration += 1\nmodel.t = (model.t + sim.ΔT) % 1440 # Time of day in minutes, resets at midnight\n\n# --- Update Date and Season ---\n# Calculate the current calendar day and month from the iteration number\norigin = DateTime(2025, 1, 1, 0, 0)\nelapsed_minutes = (model.iteration - 1) * sim.ΔT\ncurrent_datetime = origin + Minute(round(Int, elapsed_minutes))\ncurrent_date = Date(current_datetime)\nmonth_index = month(current_date)\nday_index = dayofyear(current_date)\n\n# If the month has changed, redistribute the resource grids\nif month_index != envi.ts\n    move_resources!(model, month_index)\nend\n\n# At the start of a new year, reset fishery quotas\nif day_index == 1\n    (fishery -&gt; (fishery.cumulative_catch = 0; fishery.cumulative_inds = 0)).(fisheries)\nend\n\n# Update the environment's current month\nenvi.ts = month_index\n\n# Print the current date to the console for user feedback\nprint(current_date)\nprint(\": \")\n\n# --- Main Agent Processing Loop ---\n# This loop iterates over each focal species defined in the model\nfor spec in 1:species\n    species_data = model.individuals.animals[spec].data\n    species_chars = model.individuals.animals[spec].p\n\n    # Find all living agents for the current species\n    # This requires a copy from GPU to CPU to use `findall`\n    cpu_alive = Array(species_data.alive)\n    living::Vector{Int64} = findall(x -&gt; x == 1, cpu_alive)\n    \n    if !isempty(living)\n        # --- Calculate and print population summary statistics ---\n        model.abund[spec] = sum(Array(species_data.abundance[living]))\n        model.bioms[spec] = sum(Array(species_data.biomass_school[living]))\n        print(length(living))\n        print(\"  Abundance: \")\n        print(model.abund[spec])\n        print(\"  Mean Length: \")\n        println(mean(Array(species_data.length[living])))\n\n        # --- Execute Agent Sub-models ---\n        print(\"behave | \")\n        behavior(model, spec, living, outputs)\n\n        ind_temp = individual_temp!(model, spec)\n\n        print(\"energy | \")\n        energy!(model, spec, ind_temp, living)\n\n        print(\"fish | \")\n        if (model.iteration &gt; model.spinup)\n            fishing!(model, spec, day_index, outputs)\n        end\n    end\n    \n    # Age all individuals of the species by one timestep\n    species_data.age .+= (model.dt / 1440)\nend\n\nprint(\"resources | \")\n# --- Update Resource Grids ---\nresource_predation!(model, outputs)\nresource_growth!(model)\nresource_mortality!(model)\n\nprintln(\"results | \")\n\n# --- Save Model Output ---\n# Check if the current timestep is an output step\nif (model.t % model.output_dt == 0)\n    timestep_results(sim)\n    if (model.iteration &gt; model.spinup)\n        fishery_results(sim)\n    end\nend\n\n# --- Reset Per-Timestep Accumulators ---\n# Reset variables like ration and active time to zero for all agents\nfor spec in 1:species\n    model.individuals.animals[spec].data.ration .= 0.0\n    model.individuals.animals[spec].data.active .= 0.0\nend\n\n# Annual reset for fisheries\nif day_index == 365\n    (fishery -&gt; (fishery.cumulative_catch = 0; fishery.cumulative_inds = 0)).(fisheries)\nend\nend",
    "crumbs": [
      "Model Components",
      "The Simulation Timestep"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "\nSwimmingIndividuals.jl\n",
    "section": "",
    "text": "A High-Performance Agent-Based Model for Marine Ecosystems",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "\nSwimmingIndividuals.jl\n",
    "section": "Introduction",
    "text": "Introduction\nWelcome to the official user guide for SwimmingIndividuals.jl v1.0. This documentation provides a comprehensive resource for understanding the model’s architecture, configuring and running simulations, and analyzing the output.\nSwimmingIndividuals.jl is a next-generation modeling framework designed to simulate the life histories and population dynamics of marine organisms. It is built in the high-performance Julia programming language and leverages modern parallel computing to run efficiently on both multi-core CPUs and NVIDIA GPUs.\nThe model’s core philosophy is to simulate ecosystems from the bottom-up, where large-scale patterns in population size, distribution, and structure emerge from the mechanistic, process-based decisions of individual agents.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#key-features",
    "href": "index.html#key-features",
    "title": "\nSwimmingIndividuals.jl\n",
    "section": "🔑 Key Features",
    "text": "🔑 Key Features\n\n\n\n🧠 Mechanistic Biology\nAgents are governed by detailed, process-based sub-models for movement, behavior, bioenergetics, and predation.\n\n\n\n\n📊 Data-Driven\nThe model world is built from standard NetCDF and CSV files, allowing for easy integration with real-world environmental data.\n\n\n\n\n🧩 Flexible & Modular\nThe framework is designed to be extensible, allowing users to easily define new species, behaviors, and fishery regulations.\n\n\n\n\n⚡ High-Performance\nThe dual CPU/GPU architecture allows for the simulation of millions of individual agents over large spatial and temporal scales.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#how-to-use-this-guide",
    "href": "index.html#how-to-use-this-guide",
    "title": "\nSwimmingIndividuals.jl\n",
    "section": "📘 How to Use This Guide",
    "text": "📘 How to Use This Guide\nThis user guide is organized to walk you through the entire process of using the model from setup to analysis.\nUse the sidebar to navigate through:\n\nInput configuration\nModel components\nSimulation setup and execution\nOutput and diagnostics\nExample applications\n\nLast updated: July 22, 2025",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "model_setup.html",
    "href": "model_setup.html",
    "title": "SwimmingIndividuals.jl",
    "section": "",
    "text": "This is the main entry point for running a SwimmingIndividuals simulation. This script is responsible for loading all necessary packages and source code files, reading input data from CSVs, setting up the model parameters, and launching the simulation loop.\n\n\nThe script performs the following key tasks in order:\n\nPackage Loading: It loads all required Julia packages, including PlanktonIndividuals.jl, CUDA.jl for GPU support, and various data handling and analysis libraries.\nInclude Source Files: It includes all the custom Julia source code files from the src/ directory, making functions like generate_environment!, TimeStep!, etc., available.\nLoad Input Data: It reads the files.csv manifest to get the paths to all other input data files, such as agent traits, environmental preferences, and fishery regulations.\nSet Parameters: It parses the main parameters file to configure the simulation, including the number of species, the number of timesteps, and the computational architecture (CPU or GPU).\nInitialize Model Components: It calls the high-level functions to generate the environment, calculate habitat capacities, and create the initial populations of both focal species and resource grids.\nRun Simulation: It assembles the final MarineModel and MarineSimulation objects and passes them to the runSI function to start the time-stepping loop.\n\n\n\n\n# --- 1. Load All Necessary Packages ---\nusing PlanktonIndividuals, Distributions, Random, CSV, DataFrames, StructArrays,Statistics,Dates,Optim,LinearAlgebra, Tables, CUDA, LoopVectorization, NCDatasets,StaticArrays,Interpolations, DelimitedFiles, StatsBase,Plots, Distributions, NearestNeighbors, QuadGK,Printf, HDF5, NCDatasets\n\n#using Profile, ProfileView, Cthulhu, BenchmarkTools #Only use for benchmarking purposes\nusing PlanktonIndividuals.Grids\nusing PlanktonIndividuals.Architectures: device, Architecture, GPU, CPU, rng_type, array_type\nusing KernelAbstractions\nusing KernelAbstractions: @kernel, @index\nusing CUDA: @atomic, atomic_cas!, atomic_sub!\n\n# --- 2. Include All Model Source Code Files ---\n# This makes the custom functions defined in the /src directory available to this script.\ninclude(\"src/utilities.jl\")\ninclude(\"src/create.jl\")\ninclude(\"src/environment.jl\")\ninclude(\"src/simulation.jl\")\ninclude(\"src/output.jl\")\ninclude(\"src/behavior.jl\")\ninclude(\"src/movement.jl\")\ninclude(\"src/predation.jl\")\ninclude(\"src/mortality.jl\")\ninclude(\"src/fisheries.jl\")\ninclude(\"src/energy.jl\")\ninclude(\"src/timestep.jl\")\ninclude(\"src/analysis.jl\")\ninclude(\"src/update.jl\")\n\n# --- 3. Load Input Data from CSV Files ---\n# The `files.csv` acts as a manifest, pointing to all other input files.\nfiles = CSV.read(\"inputs/files.csv\",DataFrame) \n\n# Load the specific data files using the paths from the manifest\ntrait = Dict(pairs(eachcol(CSV.read(files[files.File .== \"focal_trait\",:Destination][1],DataFrame)))) \nresource_trait = CSV.read(files[files.File .== \"resource_trait\",:Destination][1],DataFrame)\nparams = CSV.read(files[files.File .== \"params\",:Destination][1],DataFrame) \ngrid = CSV.read(files[files.File .== \"grid\",:Destination][1],DataFrame) \nfisheries = CSV.read(files[files.File .== \"fisheries\",:Destination][1],DataFrame)\nenvi_file = files[files.File .== \"environment\",:Destination][1]\n\n# --- 4. Parse and Set Up Simulation Parameters ---\n# Extract key parameters from the loaded `params` DataFrame\nNsp = parse(Int64,params[params.Name .== \"numspec\", :Value][1])         # Number of focal species\nNresource = parse(Int64,params[params.Name .== \"numresource\", :Value][1]) # Number of resource species\noutput_dt = parse(Int64,params[params.Name .== \"output_dt\", :Value][1])   # Frequency of output (in timesteps)\nspinup = parse(Int64,params[params.Name .== \"spinup\", :Value][1])        # Number of timesteps for model burn-in\nplt_diags = parse(Int64,params[params.Name .== \"plt_diags\", :Value][1])   # Boolean (1 or 0) to control diagnostic plots\n\n# Set the maximum number of agents per species. This is critical for memory allocation.\nmaxN = 500000\n# Determine the computational architecture (CPU or GPU) from the parameters file\narch_str = params[params.Name .== \"architecture\", :Value][1]\n\n# Logic to select the architecture and provide user feedback\nif arch_str == \"GPU\"\n    if CUDA.functional()\n        arch = GPU()\n        println(\"✅ Architecture successfully set to GPU.\")\n    else\n        @warn \"GPU specified but CUDA is not functional. Falling back to CPU.\"\n        arch = CPU()\n    end\nelseif arch_str == \"CPU\"\n    arch = CPU()\n    println(\"✅ Architecture successfully set to CPU.\")\nelse\n    @warn \"Architecture '$arch_str' not recognized. Defaulting to CPU.\"\n    arch = CPU()\nend\n\n# Initialize model time and timestep parameters\nt = 0.0 # Initial time\nn_iteration = parse(Int,params[params.Name .== \"nts\", :Value][1]) # Total number of timesteps to run\ndt = parse(Int,params[params.Name .== \"model_dt\", :Value][1])   # Duration of a single timestep in minutes\nn_iters = parse(Int16,params[params.Name .== \"n_iter\", :Value][1]) # Number of replicate simulation runs\n\n# --- 5. Initialize Model Components ---\n# Create the environment object from the NetCDF file\nenvi = generate_environment!(arch, envi_file,plt_diags)\n\n# Create the depth information struct\ndepths = generate_depths(files)\n\n# Calculate the habitat capacity maps for all species and months\ncapacities = initial_habitat_capacity(envi,Nsp,Nresource,files,arch,plt_diags)\n\n# --- 6. Main Simulation Loop ---\n# This loop runs multiple replicate simulations (controlled by n_iters)\nfor iter in 1:n_iters\n    # Get the initial biomass targets for each focal species\n    B = trait[:Biomass][1:Nsp]\n\n    # Create the focal species agents and place them in the environment\n    inds = generate_individuals(trait, arch, Nsp, B, maxN,depths,capacities,dt,envi)\n\n    # Initialize the resource biomass grids\n    resources = initialize_resources(resource_trait,Nsp,Nresource,depths,capacities,arch)\n\n    # Load the fishery regulations and data\n    fishery = load_fisheries(fisheries)\n\n    # Initialize vectors to track population-level statistics\n    init_abund = fill(0,Nsp)\n    bioms = fill(0.0,Nsp)\n\n    for sp in 1:Nsp\n        init_abund[sp] = sum(inds.animals[sp].data.abundance)\n        bioms[sp] = sum(inds.animals[sp].data.biomass_school)\n    end\n\n    # Assemble the complete model object containing the full simulation state\n    model = MarineModel(arch,envi,depths, fishery, t, 0,dt, inds,resources,resource_trait, capacities,maxN, Nsp,Nresource,init_abund,bioms,init_abund, files, output_dt,spinup)\n\n    # Create the output arrays for storing results\n    outputs = generate_outputs(model)\n\n    # Create the simulation object that bundles the model and run parameters\n    sim = MarineSimulation(model, dt, n_iteration,iter,outputs)\n\n    # Launch the simulation\n    runSI(sim)\nend",
    "crumbs": [
      "Model Setup & Initialization"
    ]
  },
  {
    "objectID": "model_setup.html#model-setup-initialization",
    "href": "model_setup.html#model-setup-initialization",
    "title": "SwimmingIndividuals.jl",
    "section": "",
    "text": "This is the main entry point for running a SwimmingIndividuals simulation. This script is responsible for loading all necessary packages and source code files, reading input data from CSVs, setting up the model parameters, and launching the simulation loop.\n\n\nThe script performs the following key tasks in order:\n\nPackage Loading: It loads all required Julia packages, including PlanktonIndividuals.jl, CUDA.jl for GPU support, and various data handling and analysis libraries.\nInclude Source Files: It includes all the custom Julia source code files from the src/ directory, making functions like generate_environment!, TimeStep!, etc., available.\nLoad Input Data: It reads the files.csv manifest to get the paths to all other input data files, such as agent traits, environmental preferences, and fishery regulations.\nSet Parameters: It parses the main parameters file to configure the simulation, including the number of species, the number of timesteps, and the computational architecture (CPU or GPU).\nInitialize Model Components: It calls the high-level functions to generate the environment, calculate habitat capacities, and create the initial populations of both focal species and resource grids.\nRun Simulation: It assembles the final MarineModel and MarineSimulation objects and passes them to the runSI function to start the time-stepping loop.\n\n\n\n\n# --- 1. Load All Necessary Packages ---\nusing PlanktonIndividuals, Distributions, Random, CSV, DataFrames, StructArrays,Statistics,Dates,Optim,LinearAlgebra, Tables, CUDA, LoopVectorization, NCDatasets,StaticArrays,Interpolations, DelimitedFiles, StatsBase,Plots, Distributions, NearestNeighbors, QuadGK,Printf, HDF5, NCDatasets\n\n#using Profile, ProfileView, Cthulhu, BenchmarkTools #Only use for benchmarking purposes\nusing PlanktonIndividuals.Grids\nusing PlanktonIndividuals.Architectures: device, Architecture, GPU, CPU, rng_type, array_type\nusing KernelAbstractions\nusing KernelAbstractions: @kernel, @index\nusing CUDA: @atomic, atomic_cas!, atomic_sub!\n\n# --- 2. Include All Model Source Code Files ---\n# This makes the custom functions defined in the /src directory available to this script.\ninclude(\"src/utilities.jl\")\ninclude(\"src/create.jl\")\ninclude(\"src/environment.jl\")\ninclude(\"src/simulation.jl\")\ninclude(\"src/output.jl\")\ninclude(\"src/behavior.jl\")\ninclude(\"src/movement.jl\")\ninclude(\"src/predation.jl\")\ninclude(\"src/mortality.jl\")\ninclude(\"src/fisheries.jl\")\ninclude(\"src/energy.jl\")\ninclude(\"src/timestep.jl\")\ninclude(\"src/analysis.jl\")\ninclude(\"src/update.jl\")\n\n# --- 3. Load Input Data from CSV Files ---\n# The `files.csv` acts as a manifest, pointing to all other input files.\nfiles = CSV.read(\"inputs/files.csv\",DataFrame) \n\n# Load the specific data files using the paths from the manifest\ntrait = Dict(pairs(eachcol(CSV.read(files[files.File .== \"focal_trait\",:Destination][1],DataFrame)))) \nresource_trait = CSV.read(files[files.File .== \"resource_trait\",:Destination][1],DataFrame)\nparams = CSV.read(files[files.File .== \"params\",:Destination][1],DataFrame) \ngrid = CSV.read(files[files.File .== \"grid\",:Destination][1],DataFrame) \nfisheries = CSV.read(files[files.File .== \"fisheries\",:Destination][1],DataFrame)\nenvi_file = files[files.File .== \"environment\",:Destination][1]\n\n# --- 4. Parse and Set Up Simulation Parameters ---\n# Extract key parameters from the loaded `params` DataFrame\nNsp = parse(Int64,params[params.Name .== \"numspec\", :Value][1])         # Number of focal species\nNresource = parse(Int64,params[params.Name .== \"numresource\", :Value][1]) # Number of resource species\noutput_dt = parse(Int64,params[params.Name .== \"output_dt\", :Value][1])   # Frequency of output (in timesteps)\nspinup = parse(Int64,params[params.Name .== \"spinup\", :Value][1])        # Number of timesteps for model burn-in\nplt_diags = parse(Int64,params[params.Name .== \"plt_diags\", :Value][1])   # Boolean (1 or 0) to control diagnostic plots\n\n# Set the maximum number of agents per species. This is critical for memory allocation.\nmaxN = 500000\n# Determine the computational architecture (CPU or GPU) from the parameters file\narch_str = params[params.Name .== \"architecture\", :Value][1]\n\n# Logic to select the architecture and provide user feedback\nif arch_str == \"GPU\"\n    if CUDA.functional()\n        arch = GPU()\n        println(\"✅ Architecture successfully set to GPU.\")\n    else\n        @warn \"GPU specified but CUDA is not functional. Falling back to CPU.\"\n        arch = CPU()\n    end\nelseif arch_str == \"CPU\"\n    arch = CPU()\n    println(\"✅ Architecture successfully set to CPU.\")\nelse\n    @warn \"Architecture '$arch_str' not recognized. Defaulting to CPU.\"\n    arch = CPU()\nend\n\n# Initialize model time and timestep parameters\nt = 0.0 # Initial time\nn_iteration = parse(Int,params[params.Name .== \"nts\", :Value][1]) # Total number of timesteps to run\ndt = parse(Int,params[params.Name .== \"model_dt\", :Value][1])   # Duration of a single timestep in minutes\nn_iters = parse(Int16,params[params.Name .== \"n_iter\", :Value][1]) # Number of replicate simulation runs\n\n# --- 5. Initialize Model Components ---\n# Create the environment object from the NetCDF file\nenvi = generate_environment!(arch, envi_file,plt_diags)\n\n# Create the depth information struct\ndepths = generate_depths(files)\n\n# Calculate the habitat capacity maps for all species and months\ncapacities = initial_habitat_capacity(envi,Nsp,Nresource,files,arch,plt_diags)\n\n# --- 6. Main Simulation Loop ---\n# This loop runs multiple replicate simulations (controlled by n_iters)\nfor iter in 1:n_iters\n    # Get the initial biomass targets for each focal species\n    B = trait[:Biomass][1:Nsp]\n\n    # Create the focal species agents and place them in the environment\n    inds = generate_individuals(trait, arch, Nsp, B, maxN,depths,capacities,dt,envi)\n\n    # Initialize the resource biomass grids\n    resources = initialize_resources(resource_trait,Nsp,Nresource,depths,capacities,arch)\n\n    # Load the fishery regulations and data\n    fishery = load_fisheries(fisheries)\n\n    # Initialize vectors to track population-level statistics\n    init_abund = fill(0,Nsp)\n    bioms = fill(0.0,Nsp)\n\n    for sp in 1:Nsp\n        init_abund[sp] = sum(inds.animals[sp].data.abundance)\n        bioms[sp] = sum(inds.animals[sp].data.biomass_school)\n    end\n\n    # Assemble the complete model object containing the full simulation state\n    model = MarineModel(arch,envi,depths, fishery, t, 0,dt, inds,resources,resource_trait, capacities,maxN, Nsp,Nresource,init_abund,bioms,init_abund, files, output_dt,spinup)\n\n    # Create the output arrays for storing results\n    outputs = generate_outputs(model)\n\n    # Create the simulation object that bundles the model and run parameters\n    sim = MarineSimulation(model, dt, n_iteration,iter,outputs)\n\n    # Launch the simulation\n    runSI(sim)\nend",
    "crumbs": [
      "Model Setup & Initialization"
    ]
  }
]